# -*- coding: utf-8 -*-
'''
/***************************************************************************
 Suews_database_manager
                                 A QGIS plugin
 This plugin prepare suews lib data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-05-20
        git sha              : $Format:%H$
        copyright            : (C) 2021 by GU
        email                : oskar.backlin@gu.se
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
'''
from os import stat_result, write
from xml.etree.ElementTree import ProcessingInstruction
from pandas.core.indexes import base
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon, QPixmap
from qgis.PyQt.QtWidgets import QFileDialog, QAction, QMessageBox
from qgis.core import QgsVectorLayer, QgsMapLayerProxyModel, QgsProject
# Initialize Qt resources from file resources.py
from .tabs.urban_type_creator_tab import UrbanTypeCreator
from .tabs.urban_type_editor_tab import UrbanTypeEditor
from .tabs.urban_type_db_editor_tab import UrbanTypeDBEditor
from .tabs.urban_elements_creator_tab import UrbanElementsCreator
from .tabs.urban_ESTM import ESTM_creator
from .tabs.urban_ref_manager import UrbanRefManager
from .tabs.urban_profiles import ProfileCreator
from .tabs.urban_irrigation import Irrigation_manager
from .resources import *
from pathlib import Path
import geopandas as gpd
import webbrowser
import pandas as pd
import codecs

# from timezonefinder import TimezoneFinder as tf
import urllib
import time
import re

# Import the code for the dialog
from .Urban_type_creator_dialog import Urban_type_creatorDialog
import os.path


class Urban_type_creator(object):
    '''QGIS Plugin Implementation.'''

    def __init__(self, iface):
        print('__init__')
        '''Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGISs
            application at run time.
        :type iface: QgsInterface
        '''
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Urban_type_creator_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Urban_type_creator')

        self.dlg = Urban_type_creatorDialog()
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Declare Variables
        self.outputfile = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        '''Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        '''
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Urban_type_creator', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        '''Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        '''

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        '''Create the menu entries and toolbar icons inside the QGIS GUI.'''

        icon_path = ':/plugins/Urban_type_creator/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = False

    def unload(self):
        '''Removes the plugin menu item and icon from QGIS GUI.'''
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Urban_type_creator'),
                action)
            self.iface.removeToolBarIcon(action)

    def setup_tabs(self):
        self.dlg.tabWidget.clear()

        urban_creator = UrbanTypeCreator()
        self.setup_urban_type_creator(urban_creator)
        self.dlg.tabWidget.addTab(urban_creator, 'Urban Type Classifier')

        urban_editor = UrbanTypeEditor()
        self.setup_urban_type_editor(urban_editor)
        self.dlg.tabWidget.addTab(urban_editor, 'Urban Type Editor')

        urban_elements_creator = UrbanElementsCreator()
        self.setup_urban_elements_creator(urban_elements_creator)
        self.dlg.tabWidget.addTab(urban_elements_creator, 'Urban Elements Creator')

        urban_db_editor = UrbanTypeDBEditor()
        self.setup_urban_db_type_editor(urban_db_editor)
        self.dlg.tabWidget.addTab(urban_db_editor, 'SUEWS Table Editor')

        estm_creator = ESTM_creator()
        self.setup_ESTM_creator(estm_creator)
        self.dlg.tabWidget.addTab(estm_creator, 'ESTM_Creator')

        profile_creator = ProfileCreator()
        self.setup_profile_creator(profile_creator)
        self.dlg.tabWidget.addTab(profile_creator, 'Profile Creator')

        irrigation_manager = Irrigation_manager()
        self.setup_irrigation_manager(irrigation_manager)
        self.dlg.tabWidget.addTab(irrigation_manager, 'Irrigation Manager')

        ref_manager = UrbanRefManager()
        self.setup_ref_manager(ref_manager)
        self.dlg.tabWidget.addTab(ref_manager, 'Reference Manager')


    #################################################################################################
    #                                                                                               #
    #                                     Urban Type Classifier                                     #
    #                                                                                               #
    #################################################################################################

    def setup_urban_type_creator(self, dlg):
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = UrbanTypeCreator()
        # dlg_ = UrbanTypeCreator()


        def layer_changed():
                layer = self.layerComboManagerPoint.currentLayer()
                att_list = list(layer.attributeAliases())
                try:
                    dlg.comboBoxField.clear()
                    dlg.comboBoxField.setEnabled(True)
                    dlg.comboBoxField.addItems(att_list)
                    dlg.comboBoxField.setCurrentIndex(0)

                    field_changed() 
                except:
                    pass
       
        def field_changed():

                layer = self.layerComboManagerPoint.currentLayer()
                att_list = list(layer.attributeAliases())
                try: 
                    att_column = dlg.comboBoxField.currentText()
                    att_index = att_list.index(att_column)
                    
                    unique_values = list(layer.uniqueValues(att_index))
                    len_uv = len(unique_values)

                    # Ensure always String 
                    unique_values = ([str(x) for x in unique_values])

                    for i in range(1,14):
                        # Oc == Old Class
                        Oc = eval('dlg.comboBoxClass' + str(i))
                        Oc.clear()
                        Oc.setDisabled(True)
                        vars()['dlg.comboBoxClass' + str(i)] = Oc
                        # Nc == New Class
                        Nc = eval('dlg.comboBoxNew' + str(i))
                        Nc.setCurrentIndex(-1)
                        Nc.setDisabled(True)
                        vars()['dlg.comboBoxNew' + str(i)] = Nc
                    
                    # Add Items to left side Comboboxes and enable right side comboboxes 
                    for i in range(len_uv):
                        idx = i+1
                        if idx > 13:
                            break 
                        Oc = eval('dlg.comboBoxClass' + str(idx))
                        Oc.addItems(unique_values)
                        Oc.setCurrentIndex(i)
                        vars()['dlg.comboBoxClass' + str(idx)] = Oc

                        Nc = eval('dlg.comboBoxNew' + str(idx))
                        Nc.setEnabled(True)
                        vars()['dlg.comboBoxNew' + str(idx)] = Nc
                except:
                    pass

        def typeInfo(): 

            dlg.textOutput.clear()
            dlg.Qlabel.clear()

            db_path = self.plugin_dir + '/database_copy.xlsx'
            db = pd.read_excel(db_path, sheet_name= 'Lod1_Types', index_col=  'ID', engine= 'openpyxl')

            type_list = []
            for i in range(len(db)):
                type_list.append(str(db['Type'].iloc[i]) + ', ' + str(db['Origin'].iloc[i]))
            db['type_Origin'] = type_list
          
            urb_type = dlg.comboBoxType.currentText() 
            selection = db.loc[db['type_Origin'] == urb_type]
            
            try:
                dlg.textBrowser.setText(
                    'Urban Type Info: '+ selection['Type'].item() +
                    '\n\nOrigin: ' +  selection['Origin'].item() +
                    '\n\nPeriod: ' + str(selection['Period'].item()) + 
                    '\n\nDescription: ' + str(selection['Description'].item()) +
                    '\n\nAuthor: ' + str(selection['Author'].item()) 
                    )

                # Test if reference picture exists
                try:
                    url = str(selection['Url'].item())
                    data = urllib.request.urlopen(url).read()
                    pixmap = QPixmap()
                    pixmap.loadFromData(data)
                    dlg.Qlabel.setPixmap(pixmap.scaled(500,700, QtCore.Qt.KeepAspectRatio))
                except:
                    dlg.Qlabel.setText('No reference Image avalible for this Type')
            except:
                pass

        def savefile():
            # Add possibilites to save as other format? Is .shp only format used in SUEWS Prepare?
            self.outputfile = self.fileDialog.getSaveFileName(None, 'Save File As:', None, 'Shapefiles (*.shp)')
            dlg.textOutput.setText(self.outputfile[0])

        def help():
            url = 'https://github.com/gusbacos/UTDB'
            # To readthedocs? 
            webbrowser.open_new_tab(url)

        def updateDB():

            Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()
            suews_Type, suews_veg, suews_nonveg, suews_water, suews_ref, suews_alb, suews_em, suews_OHM, suews_LAI, suews_st, suews_cnd, suews_LGP, suews_dr,suews_VG, suews_ANOHM, suews_BIOCO2, suews_MVCND, suews_por = self.read_suews_db()
            table_dict,table_dict_ID,table_dict_pd,dict_str_var, dict_gen_type = self.get_dicts(veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)
            rev_table_dict = dict((v, k) for k, v in table_dict.items())


            local_db = [Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por]
            suews_db = [suews_Type, suews_veg, suews_nonveg, suews_water, suews_ref, suews_alb, suews_em, suews_OHM, suews_LAI, suews_st, suews_cnd, suews_LGP, suews_dr,suews_VG, suews_ANOHM, suews_BIOCO2, suews_MVCND, suews_por]

            # change_list = []
            for local, suews in zip(local_db, suews_db):
                merge = pd.concat([local, suews]).drop_duplicates(keep='first')
                if len(merge) > 0:
                    var = rev_table_dict[local.name]
                    # change_list = change_list.append(str(rev_table_dict[local.name]))
                    if var == 'Type':
                        Type = merge
                    elif var == 'Veg':
                        veg = merge
                    elif var == 'NonVeg':
                        nonveg = merge
                    elif var == 'Water':
                        water = merge
                    elif var == 'Referece':
                        ref = merge
                    elif var == 'Emissivity':
                        em = merge
                    elif var == 'Albedo':
                        alb = merge
                    elif var == 'OHM':
                        OHM = merge
                    elif var == 'Leaf Area Index':
                        LAI = merge
                    elif var == 'Conductance':
                        cnd = merge
                    elif var == 'Leaf Growth Power':
                        LGP = merge
                    elif var == 'Drainage':
                        dr = merge
                    elif var == 'Vegetation Growth':
                        VG = merge
                    elif var == 'ANOHM':
                        ANOHM = merge
                    elif var == 'Biogen CO2':
                        BIOCO2 = merge
                    elif var == 'Max Vegetation Conductance':
                        MVCND = merge
                    elif var == 'Porosity':
                        por = merge
                    elif var == 'Water Storage':
                        st = merge
                    else:
                        print(var)

            self.write_to_db(Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            QMessageBox.information(None, 'Sucessful','Database Updated \nNew Entries have been added [provide more rich message here]' )


        def start_progress():
            att_field =  dlg.comboBoxField.currentText()

            vlayer = self.layerComboManagerPoint.currentLayer()

            # Read Vectorlayer Path
            gdf = gpd.read_file(str(vlayer.dataProvider().dataSourceUri()))

            dict_reclass = {}

            idx = 1
            for i in range(len(set(gdf[att_field]))):
                if idx > 13:
                    break 
                # Left side
                Oc = eval('dlg.comboBoxClass' + str(idx))
                oldField = Oc.currentText()
                vars()['dlg.comboBoxClass' + str(idx)] = Oc
                
                # Right Side
                Nc = eval('dlg.comboBoxNew' + str(idx))
                newField = Nc.currentText()
                vars()['dlg.comboBoxNew' + str(idx)] = Nc
                
                dict_reclass[str(oldField)] = str(newField)

                idx += 1

        
            # Backup not using GeoPandas

            # vlayer_provider=vlayer.dataProvider()
            # vlayer.dataProvider().addAttributes([QgsField('newfield',QVariant.String)])
            # vlayer.updateFields()
            # print (layer.fields().names())
            # #layer = iface.activeLayer()
            # newfieldindex = vlayer.fields().indexFromName('newfield') #The field needs to be created in advance
            # attrmap = {} #dictionary of feature id: {field index: new value}
            # for f in vlayer.getFeatures():
            #     if f[field] in dict_reclass:
            #         attrmap[f.id()] = {newfieldindex:dict_reclass[f[field]]}

            # vlayer.dataProvider().changeAttributeValues(attrmap)

            gdf['New_class'] = gdf[att_field].map(dict_reclass)

            gdf.to_file(self.outputfile[0])

            vlayer = QgsVectorLayer(self.outputfile[0], Path(self.outputfile[0]).name[:-4])

            QgsProject.instance().addMapLayer(vlayer)
            QMessageBox.information(None, 'Process Complete', 'Your reclassified shapefile has been added to project. Proceed to SUEWS-Preprare')
            dlg.textOutput.clear()
        
        self.layerComboManagerPoint = dlg.comboBoxVector
        self.layerComboManagerPoint.setCurrentIndex(-1)
        self.layerComboManagerPoint.setFilters(QgsMapLayerProxyModel.PolygonLayer)

        dlg.pushButtonUpdateDatabase.clicked.connect(updateDB)
        dlg.pushButtonUpdateDatabase.clicked.connect(self.resetClassifier)

        def to_type_edit():
            self.dlg.tabWidget.setCurrentIndex(1)

        dlg.editTypeButton.clicked.connect(to_type_edit)

        # Set up for the run button
        dlg.runButton.clicked.connect(start_progress)

        dlg.comboBoxVector.currentIndexChanged.connect(layer_changed)
        dlg.comboBoxField.currentIndexChanged.connect(field_changed) 

         # Set up of file save dialog
        self.fileDialog = QFileDialog()
        dlg.pushButtonSave.clicked.connect(savefile)

        # Read Database 
 #       db = pd.read_csv(r'C:\Script\NGEO306\GHSL\UrbanTypes.txt', sep= '\t')
        db_path = self.plugin_dir + '/database_copy.xlsx'
        db = pd.read_excel(db_path, sheet_name= 'Lod1_Types', index_col=  'ID', engine = 'openpyxl')

        type_list = []
        for i in range(len(db)):
            type_list.append(str(db['Type'].iloc[i]) + ', ' + str(db['Origin'].iloc[i]))
        db['type_Origin'] = type_list

        dlg.comboBoxType.addItems(sorted(type_list))
        dlg.comboBoxType.setCurrentIndex(-1) 

        for i in range(1,14):
            Ls = eval('dlg.comboBoxClass' + str(i))
            Ls.clear()
            vars()['dlg.comboBoxClass' + str(i)] = Ls

            Rs = eval('dlg.comboBoxNew' + str(i))
            Rs.clear()
            Rs.addItems(sorted(type_list))
            Rs.setCurrentIndex(-1)
            vars()['dlg.comboBoxNew' + str(i)] = Rs

        
        dlg.comboBoxType.currentIndexChanged.connect(typeInfo)
        
    def resetClassifier(self):
        self.setup_tabs()
        self.dlg.tabWidget.setCurrentIndex(0)

    
    
    #################################################################################################
    #                                                                                               #
    #                                     Urban Type Editor                                         #
    #                                                                                               #
    #################################################################################################

    def setup_urban_type_editor(self, dlg):
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = urban_type_editorDialog()

        db_path = self.plugin_dir + '/database_copy.xlsx'  
        Type = pd.read_excel(db_path, sheet_name = 'Lod1_Types', index_col=  'ID', engine = 'openpyxl')
        veg = pd.read_excel(db_path, sheet_name = 'Lod2_Veg', index_col = 'ID', engine = 'openpyxl')
        nonveg = pd.read_excel(db_path, sheet_name = 'Lod2_NonVeg', index_col = 'ID', engine = 'openpyxl')
        water = pd.read_excel(db_path, sheet_name = 'Lod2_Water', index_col = 'ID', engine = 'openpyxl')

        # Add available types to combobox
        type_list = []
        for i in range(len(Type)):
            type_list.append(str(Type['Type'].iloc[i]) + ', ' + str(Type['Origin'].iloc[i]))
        Type['type_origin'] = type_list

        dlg.comboBoxTableSelect.addItems(sorted(type_list)) 
        dlg.comboBoxTableSelect.setCurrentIndex(-1)

        def check_type():

            db_path = self.plugin_dir + '/database_copy.xlsx'
            idx_col = 'ID'

            Type = pd.read_excel(db_path, sheet_name = 'Lod1_Types', index_col = idx_col, engine = 'openpyxl')

            # Name
            if dlg.textEditName.isNull():
                QMessageBox.warning(None, 'Error in Name','Enter a name for new type')
            elif dlg.textEditName.value().startswith('test'):
                QMessageBox.warning(None, 'Error in Name','Please, don´t use test as type name..')
            elif dlg.textEditName.value().startswith('Test'):
                QMessageBox.warning(None, 'Error in Name','Please, don´t use test as type name..')
            elif dlg.textEditName.value() in Type['Type'].tolist():
                QMessageBox.warning(None, 'Error in Name','The suggested type name is already taken.')
    
            # Origin
            elif dlg.textEditOrig.isNull():
                QMessageBox.warning(None, 'Error in Origin','Enter a Origin for new type')

            # Final - When all is Checked 
            else:
                QMessageBox.information(None, 'Check Complete', 'Your type is compatible with the SUEWS-Database!\nPress Generate Type to add to your local Database')
                dlg.pushButtonGen.setEnabled(True)

        def generate_type():

            Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()
            table_dict,table_dict_ID,table_dict_pd,dict_str_var, dict_gen_type = self.get_dicts(veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            dict_reclass = {
                'ID' : str('Type' + str(int(round(time.time())))),
                'Origin' : str(dlg.textEditOrig.value()),
                'Type' : str(dlg.textEditName.value()),
                'Description': dlg.textEditDesc.value(),
                'Period' : dlg.textEditPeriod.value(),
                'Url' : '', 
                'Author' : 'SUEWS',
            }

            cbox_list = [dlg.comboBoxPavedType, dlg.comboBoxBuildingType, dlg.comboBoxGrassType, dlg.comboBoxDecType, dlg.comboBoxEvrType,dlg.comboBoxBsoilType, dlg.comboBoxWaterType]
            cbox_table_list = [nonveg, nonveg, veg, veg, veg, nonveg, water]
            dict_label = ['Paved', 'Building', 'Grass', 'Decidous Tree', 'Evergreen Tree', 'Bare Soil', 'Water']

            for cbox, surf_table, label in zip(cbox_list, cbox_table_list, dict_label):
                merge_list = []
                for i in range(len(surf_table)):
                    merge_list.append(str(surf_table['Type'].iloc[i]) + ', ' + str(surf_table['Origin'].iloc[i]))
                surf_tablec = surf_table.copy()
                surf_tablec['TypeYear'] = merge_list
                
                dict_reclass[label] = surf_tablec[surf_tablec['TypeYear'] == cbox.currentText()].index.item()
                print(dict_reclass)

            Type = Type.append(pd.DataFrame.from_dict([dict_reclass]).set_index('ID'))
    
            self.write_to_db(Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

        # Update rest of ComboBoxes
        def type_changed(): 
            try:          
                urb_type = dlg.comboBoxTableSelect.currentText()
                TypeID =Type[Type['type_origin'] == urb_type].index.item()
        
                # for i in [dlg.comboBoxEvrType, dlg.comboBoxDecType, dlg.comboBoxGrassType,
                # dlg.comboBoxRoofMtr, dlg.comboBoxWaterType, dlg.QgsFieldComboBox dlg.comboBoxBsoilType]:
                #     i.clear()
        
                def add_to_combobox(cbox, sheet, surface):
                    cbox.clear()
                    item_list = sheet['Type'][sheet['Surface'] == surface].tolist()
                    origin = sheet['Origin'][sheet['Surface'] == surface].tolist()
                    
                    merge_list = []
                    for i, j in zip(item_list, origin):
                        # Join type and origin to present for user
                        merge_list.append((i + ', ' + j))

                    cbox.addItems(merge_list)
                    # Set index according to selected base type
                    try:
                        indexer = sheet.loc[Type.loc[TypeID, surface],'Type']
                        cbox.setCurrentIndex(item_list.index(indexer))
                    except:
                        pass
          
                add_to_combobox(dlg.comboBoxEvrType, veg, 'Evergreen Tree')
                add_to_combobox(dlg.comboBoxDecType, veg, 'Decidous Tree')
                add_to_combobox(dlg.comboBoxGrassType,veg, 'Grass')
                add_to_combobox(dlg.comboBoxBuildingType, nonveg,  'Building')
                add_to_combobox(dlg.comboBoxPavedType, nonveg, 'Paved')
                add_to_combobox(dlg.comboBoxBsoilType, nonveg, 'Bare Soil')
                add_to_combobox(dlg.comboBoxWaterType, water, 'Water')
            
            except:
                pass
           
        dlg.comboBoxTableSelect.currentIndexChanged.connect(type_changed)
        
        def surface_info_changed(self):
            # Clear and enable ComboBox
            dlg.comboBoxElementInfo.clear()
            dlg.comboBoxElementInfo.setEnabled(True)
            # Read what surface user has chosen
            surface = dlg.comboBoxSurface.currentText()

            # Select correct tab fom DB (Veg, NonVeg or Water)
            if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                item_list = nonveg['Type'][nonveg['Surface'] == surface].tolist()
                origin = nonveg['Origin'][nonveg['Surface'] == surface].tolist()
                clr = nonveg['Color'][nonveg['Surface'] == surface].tolist()

                app_list = []
                for item, origin, clr in zip(item_list, origin, clr):
                    # Join type and origin to present for user
                    app_list.append((clr + ' ' + item + ', ' + origin))

            elif surface == 'Water':
                item_list = nonveg['Type'][nonveg['Surface'] == surface].tolist()
                origin = nonveg['Origin'][nonveg['Surface'] == surface].tolist()

                app_list = []
                for i, j in zip(item_list, origin):
                    # Join type and origin to present for user
                    app_list.append((i + ', ' + j))
            else: 
                item_list = veg['Type'][veg['Surface'] == surface].tolist()
                origin = veg['Origin'][veg['Surface'] == surface].tolist()

                app_list = []
                for i, j in zip(item_list, origin):
                    # Join type and origin to present for user
                    app_list.append((i + ', ' + j))

            dlg.comboBoxElementInfo.addItems(app_list)
        
        
        def surface_info_changed(self):
            # Clear and enable ComboBox
            dlg.comboBoxElementInfo.clear()
            dlg.comboBoxElementInfo.setEnabled(True)
            # Read what surface user has chosen
            surface = dlg.comboBoxSurface.currentText()

            # Select correct tab fom DB (Veg, NonVeg or Water)
            if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                item_list = nonveg['Type'][nonveg['Surface'] == surface].tolist()
                origin = nonveg['Origin'][nonveg['Surface'] == surface].tolist()
                clr = nonveg['Color'][nonveg['Surface'] == surface].tolist()

                app_list = []
                for item, origin, clr in zip(item_list, origin, clr):
                    # Join type and origin to present for user
                    app_list.append((clr + ' ' + item + ', ' + origin))

            elif surface == 'Water':
                item_list = nonveg['Type'][nonveg['Surface'] == surface].tolist()
                origin = nonveg['Origin'][nonveg['Surface'] == surface].tolist()

                app_list = []
                for i, j in zip(item_list, origin):
                    # Join type and origin to present for user
                    app_list.append((i + ', ' + j))

            else: 
                item_list = veg['Type'][veg['Surface'] == surface].tolist()
                origin = veg['Origin'][veg['Surface'] == surface].tolist()

                app_list = []
                for i, j in zip(item_list, origin):
                    # Join type and origin to present for user
                    app_list.append((i + ', ' + j))

            dlg.comboBoxElementInfo.addItems(app_list)
        
        dlg.comboBoxSurface.currentIndexChanged.connect(surface_info_changed)

        dlg.pushButtonCheck.clicked.connect(check_type)
        dlg.pushButtonGen.clicked.connect(generate_type)
        dlg.pushButtonGen.clicked.connect(self.resetTypeEditor)
        #        dlg.pushButtonUpdate.clicked.connect(self.resetTypeEditor)

        def to_element_edit():
            self.dlg.tabWidget.setCurrentIndex(2)

        dlg.pushButtonEditElement.clicked.connect(to_element_edit)


    def resetTypeEditor(self):
        self.setup_tabs()
        self.dlg.tabWidget.setCurrentIndex(1)
        QMessageBox.information(None, 'Sucessful','Database Updated')

    #################################################################################################
    #                                                                                               #
    #                                  Urban Element Creator                                        #
    #                                                                                               #
    #################################################################################################

    def setup_urban_elements_creator(self, dlg):

        # Read database and get dataframes
        Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()

        table_dict,table_dict_ID,table_dict_pd,dict_str_var,dict_gen_type = self.get_dicts(veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)
     
        rev_table_dict = dict((v, k) for k, v in table_dict_ID.items())
        
        dlg.comboBoxSurface.setCurrentIndex(-1)
        
        # dlg.textBrowserColor.setDisabled(True)
        # dlg.textEditColor.setHidden(True)

        def changed_surface():
            
            for i in range(0,19):
                Oc = eval('dlg.textBrowser_' + str(i))
                Oc.clear()
                Oc.setDisabled(True)
                Nc = eval('dlg.comboBox_' + str(i))
                Nc.setDisabled(True)
                Nc.clear()
                Tb = eval('dlg.textBrowserTab' + str(i))
                Tb.setDisabled(True)
                Tb.clear()
                Cb = eval('dlg.checkBox' + str(i))
                Cb.setChecked(False)

            # Clear and enable ComboBox
            dlg.comboBoxBaseElement.clear()
            dlg.comboBoxBaseElement.setEnabled(True)
            
            # Read what surface user has chosen
            surface = dlg.comboBoxSurface.currentText()


            # Select correct tab fom DB (Veg, NonVeg or Water)
            if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                item_list = nonveg['Type'][nonveg['Surface'] == surface].tolist()
                origin = nonveg['Origin'][nonveg['Surface'] == surface].tolist()
                clr = nonveg['Color'][nonveg['Surface'] == surface].tolist()

                app_list = []
                for item, origin, clr in zip(item_list, origin, clr):
                    # Join type and origin to present for user
                    app_list.append((clr + ' ' + item + ', ' + origin))

                dlg.textBrowserColor.setEnabled(True)
                dlg.textEditColor.setEnabled(True)
            
            elif surface == 'Water':
                item_list = water['Type'][water['Surface'] == surface].tolist()
                origin = water['Origin'][water['Surface'] == surface].tolist()
                app_list = []
                for i, j in zip(item_list, origin):
                    # Join type and origin to present for user
                    app_list.append((i + ', ' + j))

                dlg.textBrowserColor.seDisabled(True)
                dlg.textEditColor.setDisabled(True)

            else: 
                item_list = veg['Type'][veg['Surface'] == surface].tolist()
                origin = veg['Origin'][veg['Surface'] == surface].tolist()
                app_list = []
                for i, j in zip(item_list, origin):
                    # Join type and origin to present for user
                    app_list.append((i + ', ' + j))

                dlg.textBrowserColor.setDisabled(True)
                dlg.textEditColor.setDisabled(True)

            dlg.comboBoxBaseElement.addItems(app_list)
            dlg.comboBoxBaseElement.setCurrentIndex(-1)

            table = table_dict_pd[str(surface)]
            col_list = list(table)

            remove_cols = ['ID', 'Surface', 'Color', 'Origin', 'Type']

            if surface != 'Decidous Tree':
                remove_cols.append('Por') # Exception for just Decidous tree in Veg

            for col in remove_cols:
                try:
                    col_list.remove(col)
                except:
                    pass
            # Clear ComboBoxes 

            for i in range(len(col_list)-1): 
                          
                Oc = eval('dlg.textBrowser_' + str(i))
                Oc.setEnabled(True)
                # Tb = Text Browser with table
                Tb = eval('dlg.textBrowserTab' + str(i))
                Tb.setEnabled(True)
                # Nc = Combobox with selectable table rows
                Nc = eval('dlg.comboBox_' + str(i))
                Nc.setEnabled(True)
                
                # Assign correct tab
                try:
                    table_name_str = rev_table_dict[col_list[i]]
                except:
                    pass
                
                # Fill in name of table
                Oc.setText(table_name_str)

                table = table_dict_pd[table_name_str]
                table_surf = table[table['Surface'] == surface]

                ref_show = ref['authoryear'].to_dict()
                table_surf['Reference'] = '' 
                for i in range(len(table_surf)):
                    table_surf['Reference'].iloc[i] = ref_show[table_surf['Ref'].iloc[i]] 
                
                table_sel = table_surf.drop(columns =['Surface','General Type', 'Ref']).reset_index()
                
                try :
                    table_surf.drop(columns =['descOrigin'])
                except:
                    pass

                table_sel = table_sel.drop(columns = ['ID'])
                Tb.setText(str(table_sel.to_html(index=True))) 

                Nc_fill_list = []
                idx = 0
                for desc, orig, idx in zip(table_surf['Description'].tolist() ,table_surf['Origin'].tolist(), list(range(len(table_surf['Origin'].tolist())))):
                    Nc_fill_list.append((str(idx) + ': ' + desc + ', ' + orig))
                
                Nc.addItems(Nc_fill_list)
        
        dlg.comboBoxSurface.currentIndexChanged.connect(changed_surface)

        def base_element_changed():
            surface = dlg.comboBoxSurface.currentText()
            surf_table = table_dict_pd[surface]
            merge_list = []
            if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                for i in range(len(table_dict_pd[surface])):
                    merge_list.append(
                        str(surf_table['Color'].iloc[i]) + 
                        ' ' + 
                        str(surf_table['Type'].iloc[i]) + 
                        ', ' +
                         str(surf_table['Origin'].iloc[i]))
                lod_2 = nonveg
            elif surface == 'Water':
                for i in range(len(table_dict_pd[surface])):
                    merge_list.append(
                        str(surf_table['Type'].iloc[i]) +
                         ', ' +
                          str(surf_table['Origin'].iloc[i]))
                lod_2 = water
                
            else:
                for i in range(len(table_dict_pd[surface])):
                    merge_list.append(
                        str(surf_table['Type'].iloc[i]) +
                         ', ' +
                          str(surf_table['Origin'].iloc[i]))
                lod_2 = veg
                
            surf_table['TypeOrigin'] = merge_list
            item_list = surf_table[surf_table['Surface'] == surface]
            base_element = dlg.comboBoxBaseElement.currentText()
            try:
                idx = item_list[item_list['TypeOrigin'] == base_element].index.item()
                # base_element_ID = surf_table[surf_table['TypeOrigin'] == base_element].index.item()
                #     # Set index according to selected base type
                # indexer = surf_table.loc[Type.loc[base_element_ID, surface],'Type']
                col_list = list(surf_table)
                remove_cols = ['ID', 'Surface', 'Color', 'Origin', 'Type']
                if surface != 'Decidous Tree':
                    remove_cols.append('Por') # Exception for just Decidous tree in Veg

                for col in remove_cols:
                    try:
                        col_list.remove(col)
                    except:
                        pass

                for i in range(len(col_list)): 
                    Nc = eval('dlg.comboBox_' + str(i))
                    Nc.setEnabled(True)
                    
                    # Assign correct tab
                    table_name_str = rev_table_dict[col_list[i]]
                    
                    table = table_dict_pd[table_name_str]
                    table_surf = table[table['Surface'] == surface]

                    origin = table['Origin'][table['Surface'] == surface].tolist()
                    merge_list = []
                    if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                        for i in range(len(table_dict_pd[surface])):
                            merge_list.append(
                                str(table_surf['Color'].iloc[i]) + 
                                ' ' + 
                                str(table_surf['Type'].iloc[i]) + 
                                ', ' +
                                str(table_surf['Origin'].iloc[i]))
                        else:
                            for i in range(len(table_dict_pd[surface])):
                                merge_list.append(
                                    str(table_surf['Type'].iloc[i]) +
                                    ', ' +
                                    str(table_surf['Origin'].iloc[i]))
                            lod_2 = veg
                    # # Set index according to selected base type

                    a  = lod_2.loc[idx, table_dict_ID[table_name_str]]
                    indexer = table_surf.loc[a, 'Description']
                    #indexer = table.loc[lod_2.loc[idx, table_dict_ID[table_name_str]],'Descripiton']
                    Nc.setCurrentIndex(item_list.index(str(indexer)))



            except:
                pass
            

        def print_table(idx):
            surface = dlg.comboBoxSurface.currentText()
            
            if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                table_name = nonveg
            elif surface == 'Water':
                table_name = water # CHANGE TO WATER
            else:
                table_name = veg

            table = table_name[table_name['Surface'] == surface]

            table_indexer = eval('dlg.textBrowserTab' + str(idx)) 
            table_indexer.clear()
            vars()['dlg.textBrowserTab' + str(idx)] = table_indexer
            
            table_id = eval('dlg.comboBox_' + str(idx))
            vars()['dlg.comboBox_' + str(idx)] = table_id
            table_id = table_id.currentText()

        def check_element(): # Add more checkers

            if len(dlg.comboBoxSurface.currentText()) <1: 
                QMessageBox.warning(None, 'Surface Missing','Please select a surface')
            elif len(dlg.textEditType.toPlainText()) <1: 
                QMessageBox.warning(None, 'Description Missing','Please fill in the Description Box')
            elif len(dlg.textEditLoc.toPlainText()) <1: 
                QMessageBox.warning(None, 'Origin Missing','Please fill in the Origin Box')
            elif dlg.comboBoxSurface.currentText() == 'Paved' or  dlg.comboBoxSurface.currentText() == 'Building' or dlg.comboBoxSurface.currentText() == 'Bare Soil':
                if len(dlg.textEditColor.toPlainText()) < 1:
                    QMessageBox.warning(None, 'Color Missing', 'Please fill in the Color Box')
            else:
                QMessageBox.information(None, 'Sucessful','Your Element is compatible. \n Press Add Element to add to your Local Database')
                dlg.pushButtonGen.setEnabled(True)

        def generate_element():
            db_path = self.plugin_dir + '/database_copy.xlsx'  

            Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()
            table_dict,table_dict_ID,table_dict_pd,dict_str_var,dict_gen_type = self.get_dicts(veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            # Nonveg or veg or water?
            surface = dlg.comboBoxSurface.currentText()

            table = table_dict_pd[surface]

            col_list = list(table)
            remove_cols = ['ID', 'Surface', 'Color', 'Origin', 'Type']
            for col in remove_cols:
                try:
                    col_list.remove(col)
                except:
                    pass

            dict_reclass = {
                'ID' : str(table_dict_ID[surface] + str(int(round(time.time())))),
                'Surface' : surface,
                'Origin' : str(dlg.textEditLoc.toPlainText()),
                'Type' : str(dlg.textEditType.toPlainText()),
                #'Author' : str(dlg.textEditAutor.toPlainText())
            }

            for i in range(len(col_list)-1):
                Oc = eval('dlg.textBrowser_' + str(i))
                oldField = Oc.toPlainText()
                Nc = eval('dlg.comboBox_' + str(i))
                sel_att = Nc.currentText() 

                table = table_dict_pd[oldField]

                descOrigin_list = []
                for i in range(len(table)):
                    descOrigin_list.append(str(table['Description'].iloc[i]) + ', ' + str(table['Origin'].iloc[i]))

                idx_table= table.copy()
                idx_table['descOrigin'] = descOrigin_list

                sel_att = sel_att.split(': ')[1] # Remove number added for interpretation in GUI

                newField = idx_table.loc[idx_table['descOrigin'] == sel_att].index.item()
                dict_reclass[table_dict_ID[oldField]] = newField
                idx_table.drop(columns = 'descOrigin')
            
            df_new_edit = pd.DataFrame(dict_reclass, index = [0]).set_index('ID')
            # Add new line to correct tab veg, nonveg or water
            if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                df_new_edit['Color'] = dlg.textEditColor.toPlainText()
                nonveg = nonveg.append(df_new_edit)
            elif surface == 'Water':
                water = water.append(df_new_edit)
            else:
                veg = veg.append(df_new_edit)
            
            # Write to db
            self.write_to_db(Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            QMessageBox.information(None, 'Sucessful','Element Added')

        dlg.pushButtonCheck.clicked.connect(check_element)
        dlg.pushButtonGen.clicked.connect(generate_element)
        dlg.comboBoxBaseElement.currentIndexChanged.connect(base_element_changed)
        dlg.pushButtonGen.clicked.connect(self.reset_surface_editor)

    def reset_surface_editor(self):
        self.setup_tabs()
        self.dlg.tabWidget.setCurrentIndex(2)




    #################################################################################################
    #                                                                                               #
    #                                  Urban Table Editor                                        #
    #                                                                                               #
    #################################################################################################

    # TODO CHANGE Numbers in combo and scrollboxes to 0 and drop description and origin 

    def setup_urban_db_type_editor(self, dlg):

        for i in range(0,15):
            Oc = eval('dlg.textBrowser_' + str(i))
            Oc.clear()
            Oc.setDisabled(True)

            Nc = eval('dlg.textEdit_Edit_' + str(i))
            Nc.clear()
            Nc.setDisabled(True)
        
        Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()
        table_dict,table_dict_ID,table_dict_pd,dict_str_var,dict_gen_type = self.get_dicts(veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

        rev_table_dict = dict((v, k) for k, v in table_dict.items())
        
        # Remove Conductance in some way
        remove_list = ['Lod1_Types', 'References', 'Lod2_Veg', 'Lod2_NonVeg', 'Lod2_Water'] # FIX THIS
        
        for sheet in remove_list:
            del rev_table_dict[sheet]

        dlg.comboBoxTableSelect.addItems(sorted((list(rev_table_dict.values()))))
        dlg.comboBoxTableSelect.setCurrentIndex(-1)
        
        ref_list = []
        for i in range(len(ref)):
            ref_list.append(str(ref['Author'].iloc[i]) + ' (' + str(ref['Publication Year'].iloc[i]) + ')')
        ref['authoryear'] = ref_list
        dlg.comboBoxRef.addItems(sorted(ref_list)) 
        dlg.comboBoxRef.setCurrentIndex(-1)
        
        def table_changed():
            table_name = dlg.comboBoxTableSelect.currentText()

            # Clear ComboBoxes
            dlg.textBrowserDf.clear()
            for i in range(0,15):
                Oc = eval('dlg.textBrowser_' + str(i))
                Oc.clear()
                Oc.setDisabled(True)
   
                Nc = eval('dlg.textEdit_Edit_' + str(i))
                Nc.clear()
                Nc.setDisabled(True)

                    
                table = table_dict_pd[str(table_name)]
                col_list = list(table)
                
                columns_to_remove = ['General Type', 'Surface', 'Description','Origin','Ref', 'Reference']

                for remove in columns_to_remove:
                    try:
                        col_list.remove(remove)
                    except:
                        pass

                len_list = len(col_list)
                for idx in range(len_list):
                    Oc = eval('dlg.textBrowser_' + str(idx))
                    Oc.setEnabled(True)
                    Oc.setText(str(col_list[idx]))

                    Nc = eval('dlg.textEdit_Edit_' + str(idx))
                    Nc.setEnabled(True)

                
                if table_name == 'Leaf Area Index' or table_name == 'Leaf Growth Power' or table_name == 'Max Vegetation Conductance' or table_name == 'Vegetation Growth' or table_name == 'Biogen CO2':
                    dlg.comboBoxSurface.clear()
                    dlg.comboBoxSurface.addItems(['Evergreen Tree', 'Decidous Tree','Grass'])
                elif table_name == 'Porosity':
                    dlg.comboBoxSurface.clear()
                    dlg.comboBoxSurface.addItems(['Decidous Tree'])
                else:
                    dlg.comboBoxSurface.clear()
                    dlg.comboBoxSurface.addItems(['Paved', 'Building','Evergreen Tree', 'Decidous Tree', 'Grass', 'Bare Soil', 'Water'])
                dlg.comboBoxSurface.setEnabled(True)
                dlg.comboBoxSurface.setCurrentIndex(-1)
                            
                ref_show = ref['authoryear'].to_dict()
                table['Reference'] = '' 
                try:
                    for i in range(len(table)):
                        table['Reference'].iloc[i] = ref_show[table['Ref'].iloc[i]] 
                except:
                    pass                
                text_table = table.drop(columns =['Surface','General Type', 'Ref']).reset_index()
    
                dlg.textBrowserDf.setText(str(text_table.drop(columns='ID').to_html()))        
                dlg.comboBoxSurface.setCurrentIndex(-1)


        dlg.comboBoxTableSelect.currentIndexChanged.connect(table_changed) 
        
        def surface_changed():
            table_name = dlg.comboBoxTableSelect.currentText()
            surface = dlg.comboBoxSurface.currentText()
            table = table_dict_pd[str(table_name)]
            table_surf = table[table['Surface'] == surface]

            ref_show = ref['authoryear'].to_dict()
            table_surf['Reference'] = '' 
            for i in range(len(table_surf)):
                table_surf['Reference'].iloc[i] = ref_show[table_surf['Ref'].iloc[i]] 
            
            text_table = table_surf.drop(columns =['Surface','General Type', 'Ref']).reset_index()

            dlg.textBrowserDf.setText(str(text_table.drop(columns='ID').to_html()))   

        dlg.comboBoxSurface.currentIndexChanged.connect(surface_changed)

        def ref_changed():
            dlg.textBrowserRef.clear()

            try:
                ID = ref[ref['authoryear'] ==  dlg.comboBoxRef.currentText()].index.item()
                dlg.textBrowserRef.setText(
                    '<b>Author: ' +'</b>' + str(ref.loc[ID, 'Author']) + '<br><br><b>' +
                    'Year: ' + '</b> '+ str(ref.loc[ID, 'Publication Year']) + '<br><br><b>' +
                    'Title: ' + '</b> ' +  str(ref.loc[ID, 'Title']) + '<br><br><b>' +
                    'Journal: ' + '</b>' + str(ref.loc[ID, 'Journal']) + '<br><br><b>' 
                )
            except:
                pass
    
        dlg.comboBoxRef.currentIndexChanged.connect(ref_changed)
        
        def add_table():

            Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()

            table_dict,table_dict_ID,table_dict_pd,dict_str_var,dict_gen_type= self.get_dicts(veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)


            table = table_dict_pd[str(dlg.comboBoxTableSelect.currentText())]

            col_list = list(table)
            
            columns_to_remove = ['General Type', 'Surface', 'Description','Origin','Ref','Reference']

            for remove in columns_to_remove:
                try:
                    col_list.remove(remove)
                except:
                    pass

            len_list = len(col_list)

            dict_reclass = {
                'ID' : str(table_dict_ID[str(dlg.comboBoxTableSelect.currentText())] + str(int(round(time.time())))),
                'General Type' : dict_gen_type[dlg.comboBoxSurface.currentText()],
                'Surface' : dlg.comboBoxSurface.currentText(), 
                'Description' : dlg.textEditDesc.value(),
                'Origin' : dlg.textEditOrig.value()
            }
        
            for idx in range(len_list):
                # Left side
                Oc = eval('dlg.textBrowser_' + str(idx))
                oldField = Oc.toPlainText()
                vars()['dlg.textBrowser_' + str(idx)] = Oc
                # Right Side
                Nc = eval('dlg.textEdit_Edit_' + str(idx))
                newField = float(Nc.value())
                vars()['dlg.textEdit_Edit_' + str(idx)] = Nc
                dict_reclass[oldField] =  [newField]

            
            dict_reclass['Ref'] = ref[ref['authoryear'] ==  dlg.comboBoxRef.currentText()].index.item() 
            
            df_new_edit = pd.DataFrame(dict_reclass).set_index('ID')

            # IF Party to write to correct sheet in .xlsx
            
            var = dlg.comboBoxTableSelect.currentText()

            if var == 'Emissivity':
                em = em.append(df_new_edit)
            if var == 'Albedo':
                alb = alb.append(df_new_edit)
            elif var == 'OHM':
                OHM = OHM.append(df_new_edit)
            elif var == 'Leaf Area Index':
                LAI = LAI.append(df_new_edit)
            elif var == 'Conductance':
                cnd = cnd.append(df_new_edit)
            elif var == 'Leaf Growth Power':
                LGP = LGP.append(df_new_edit)
            elif var == 'Drainage':
                dr = dr.append(df_new_edit)
            elif var == 'Vegetation Growth':
                VG = VG.append(df_new_edit)
            elif var == 'ANOHM':
                ANOHM = ANOHM.append(df_new_edit)
            elif var == 'Biogen CO2':
                BIOCO2 = BIOCO2.append(df_new_edit)
            elif var == 'Max Vegetation Conductance':
                MVCND = MVCND.append(df_new_edit)
            elif var == 'Porosity':
                por = por.append(df_new_edit)
            else:
                print('Error!')
            
            # Write to db
            self.write_to_db(Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            QMessageBox.information(None, 'Sucessful','Edit Added')
    
        def checker():

            def special_match(strg, search=re.compile(r'[^0-9.]').search):
                return not bool(search(strg))

            var = dlg.comboBoxTableSelect.currentText()
            try:
                if len(dlg.comboBoxSurface.currentText()) <1: 
                    QMessageBox.warning(None, 'Surface Missing','Please select a surface')
                elif len(dlg.textEditDesc.value()) <1: 
                    QMessageBox.warning(None, 'Description Missing','Please fill in the Description Box')
                elif len(dlg.textEditOrig.value()) <1: 
                    QMessageBox.warning(None, 'Origin Missing','Please fill in the Origin Box')
                elif len(dlg.comboBoxRef.currentText()) <1:
                    QMessageBox.warning(None, 'Reference Missing','Please select a reference')
            except:
                pass 
            
            table = table_dict_pd[str(dlg.comboBoxTableSelect.currentText())]

            col_list = list(table)
            
            columns_to_remove = ['General Type', 'Surface', 'Description','Origin','Ref','Reference']

            for remove in columns_to_remove:
                try:
                    col_list.remove(remove)
                except:
                    pass
            try:        
                dict_reclass = {
                    # 'ID' : str(table_dict_ID[str(dlg.comboBoxTableSelect.currentText())] + str(int(round(time.time())))),
                    'General Type' : dict_gen_type[dlg.comboBoxSurface.currentText()],
                    'Surface' : dlg.comboBoxSurface.currentText(), 
                    # 'Description' : dlg.textEditDesc.value(),
                    # 'Origin' : dlg.textEditOrig.value()
                }
            except:
                pass

            len_list = len(col_list)
            col_list =['General Type', 'Surface']

            for idx in range(len_list):
                # Left side
                Oc = eval('dlg.textBrowser_' + str(idx))
                oldField = Oc.toPlainText()
                vars()['dlg.textBrowser_' + str(idx)] = Oc
                # Right Side
                Nc = eval('dlg.textEdit_Edit_' + str(idx))

                if(len(Nc.value())) <1:
                    QMessageBox.warning(None, oldField + ' Missing','Enter value for ' + oldField)
                    break

                if Oc.toPlainText() != 'Season': # Add more to where this is fine!
                    if  special_match(Nc.value()) == False:
                        QMessageBox.warning(None, oldField + ' Error','Invalid characters in ' + oldField + '\nOnly 0-9 and . are allowed')
                        break

                try:
                    newField = float(Nc.value())
                    vars()['dlg.textEdit_Edit_' + str(idx)] = Nc
                    dict_reclass[oldField] =  [newField]
                    col_list.append(Oc.toPlainText())

                    dict_reclass['Ref'] = ref[ref['authoryear'] ==  dlg.comboBoxRef.currentText()].index.item() 
                    df_new_edit = pd.DataFrame(dict_reclass)
                    col_list.append('Ref')

                    row = len(table.index)
                    col = len(table[col_list].columns)

                    try:
                        if var == 'Albedo':
                            if float(dlg.textEdit_Edit_0.value()) < 0 or float(dlg.textEdit_Edit_0.value()) > 1:
                                QMessageBox.warning(None, 'Albedo Min error','Alb_min must be between 0-1')
                                break
                            elif float(dlg.textEdit_Edit_1.value()) < 0 or float(dlg.textEdit_Edit_1.value()) > 1:
                                QMessageBox.warning(None, 'Albedo Max error','Alb_max must be between 0-1')
                                break
                            elif float(dlg.textEdit_Edit_0.value()) > float(dlg.textEdit_Edit_1.value()):
                                QMessageBox.warning(None, 'Value error', dlg.textBrowser_0.toPlainText() + ' must be smaller or equal to ' + dlg.textBrowser_1.toPlainText())
                                break

                        elif var == 'Leaf Area Index':

                            if float(dlg.textEdit_Edit_1.value()) < 0 or float(dlg.textEdit_Edit_1.value()) > 1:
                                QMessageBox.warning(None, 'LAImin error','LAImin must be between 0-1')
                                break
                            elif float(dlg.textEdit_Edit_2.value()) < 0 or float(dlg.textEdit_Edit_2.value()) > 1:
                                QMessageBox.warning(None, 'LAImax error','LAImax must be between 0-1')
                                break
                            elif float(dlg.textEdit_Edit_1.value()) > float(dlg.textEdit_Edit_2.value()):
                                QMessageBox.warning(None, 'Value error', dlg.textBrowser_1.toPlainText() + ' must be smaller or equal to ' + dlg.textBrowser_2.toPlainText())
                                break
                            elif int(dlg.textEdit_Edit_0.value()) > 1:
                                QMessageBox.warning(None, 'LAI Equation error','LAIeq choices are 0 or 1')
                                break

                        elif var == 'Porosity':
                            if float(dlg.textEdit_Edit_0.value()) > float(dlg.textEdit_Edit_1.value()):
                                QMessageBox.warning(None, 'Value error', dlg.textBrowser_0.toPlainText() + ' must be smaller or equal to ' + dlg.textBrowser_1.toPlainText())
                                break

                        elif var == 'Emissivity':
                            if float(dlg.textEdit_Edit_0.value()) < 0 or float(dlg.textEdit_Edit_0.value()) > 1:
                                QMessageBox.warning(None, 'Emissivity error','Emissivity must be between 0-1')
                                break

                        for i in range(row):
                            checker = 0
                            for j in range(col):
                                if table[col_list].iloc[i].tolist()[j] == df_new_edit.iloc[0].tolist()[j]:
                                    checker = checker+1
                            if checker == col:
                                QMessageBox.information(None, 'Information',
                                    'Another entry in the database with same Values and Referece is found in the Database' +
                                    '\n\n[ ' +  str(table.loc[table.index[i], 'Description']) + ', ' + str(table.loc[table.index[i], 'Origin']) + 
                                    ', ' + str(table.loc[table.index[i], 'Reference'] + ' ]' +
                                    '\n\nYou are able to add the entry if you  think this is different from what already exist in the database!'))
                    
                        QMessageBox.information(None, 'Succesful', 'Your edit is compatible! Press Add Table to add it to your local database')
                        dlg.pushButtonGen.setEnabled(True)
                    except:
                        pass
                except:
                    pass

        

                
                    # #self.dlg.textBrowserNewID.setText(str(' '.join(re.findall('[a-zA-Z]+', table.index[1])))+ str(len(table)+1))
                                
                    # ref_show = ref['authoryear'].to_dict()
                    # table['Reference'] = '' 
                    # for i in range(len(table)):
                    #     table['Reference'].iloc[i] = ref_show[table['Ref'].iloc[i]] 
                    
                    # text_table = table.drop(columns =['Surface','General Type', 'Ref']).reset_index()
        
                    # dlg.textBrowserDf.setText(str(text_table.drop(columns='ID').to_html()))        
                    # dlg.comboBoxSurface.setCurrentIndex(-1)

        def to_ref_manager():
            self.dlg.tabWidget.setCurrentIndex(5)



            # elif var == 'OHM'
            #     OHM = OHM.append(df_new_edit)
            # elif var == 'Leaf Area Index':
            #     LAI = LAI.append(df_new_edit)
            # elif var == 'Conductance':
            #     cnd = cnd.append(df_new_edit)
            # elif var == 'Leaf Growth Power':
            #     LGP = LGP.append(df_new_edit)
            # elif var == 'Drainage':
            #     dr = dr.append(df_new_edit)
        # dlg.checkBoxAdvanced.stateChanged.connect(advanced_editing)
        dlg.pushButtonCheck.clicked.connect(checker)
        dlg.pushButtonGen.clicked.connect(add_table)
        dlg.pushButtonGen.clicked.connect(self.reset_DB_editor)
        # dlg.pushButtonCheckRef.clicked.connect(check_reference)
        # dlg.pushButtonAddRef.clicked.connect(add_reference)
        # dlg.pushButtonAddRef.clicked.connect(self.reset_DB_editor)
        dlg.pushButtonToRefManager.clicked.connect(to_ref_manager)

    #################################################################################################
    #                                                                                               #
    #                                  ESTM_creator                                                 #
    #                                                                                               #
    #################################################################################################

    def setup_ESTM_creator(self, dlg):

        db_path = self.plugin_dir + '/database_copy.xlsx'  
        ref = pd.read_excel(db_path, sheet_name = 'References', index_col = 'ID', engine = 'openpyxl')
        ESTM = pd.read_excel(db_path, sheet_name = 'Lod3_ESTM', index_col = 'ID', engine = 'openpyxl')
        
        item_list = ESTM['Description'].tolist()
        origin = ESTM['Origin'].tolist()

        app_list = []
        for item, origin in zip(item_list, origin):
                    app_list.append((item + ', ' + origin))
        
        ESTM['descOrigin'] = app_list
        
        for i in range(0,51):
            Tb = eval('dlg.textBrowser_' + str(i))
            Le = eval('dlg.ESTMlineEdit' + str(i))
            Le.clear()
            Le.setText(str(-999))
        
        def surface_changed():
            surface = dlg.comboBoxSurface.currentText()
            dlg.comboBoxBaseESTM.clear()

            ESTM_surf = ESTM['descOrigin'][ESTM['Surface'] == surface]
        
            dlg.comboBoxBaseESTM.addItems(ESTM_surf.tolist())

        def base_ETSM_changed():
            base_ESTM = dlg.comboBoxBaseESTM.currentText()
            ESTM_sel = ESTM[ESTM['descOrigin'] == base_ESTM]

            ESTM_sel_dict = ESTM_sel.squeeze().to_dict()

            for i in range(0,51):
                Tb = eval('dlg.textBrowser_' + str(i))
                Le = eval('dlg.ESTMlineEdit' + str(i))
                Le.clear()
                Le.setText(str(ESTM_sel_dict[Tb.toPlainText()]))


        def show_references():
            ref_list = []
            for i in range(len(ref)):
                ref_list.append(str(ref['Author'].iloc[i]) + ' (' + str(ref['Publication Year'].iloc[i]) + ')')
            ref['authoryear'] = ref_list
            dlg.comboBoxRef.addItems(sorted(ref_list)) 
            dlg.comboBoxRef.setCurrentIndex(-1)
        
        show_references()
        
        def ref_changed():
            dlg.textBrowserRef.clear()

            try:
                ID = ref[ref['authoryear'] ==  dlg.comboBoxRef.currentText()].index.item()
                dlg.textBrowserRef.setText(
                    '<b>Author: ' +'</b>' + str(ref.loc[ID, 'Author']) + '<br><br><b>' +
                    'Year: ' + '</b> '+ str(ref.loc[ID, 'Publication Year']) + '<br><br><b>' +
                    'Title: ' + '</b> ' +  str(ref.loc[ID, 'Title']) + '<br><br><b>' +
                    'Journal: ' + '</b>' + str(ref.loc[ID, 'Journal']) + '<br><br><b>'
                )
            except:
                pass

        dlg.comboBoxRef.currentIndexChanged.connect(ref_changed) 
        dlg.comboBoxSurface.currentIndexChanged.connect(surface_changed)
        dlg.comboBoxBaseESTM.currentIndexChanged.connect(base_ETSM_changed)

    #################################################################################################
    #                                                                                               #
    #                                  Profile creator                                              #
    #                                                                                               #
    #################################################################################################

    def setup_profile_creator(self,dlg):

        db_path = self.plugin_dir + '/database_copy.xlsx'  
        ref = pd.read_excel(db_path, sheet_name = 'References', index_col = 'ID', engine = 'openpyxl')
        prof = pd.read_excel(db_path, sheet_name = 'Lod3_Profiles', index_col = 'ID', engine = 'openpyxl')
        
        item_list = prof['Description'].tolist()
        origin = prof['Origin'].tolist()

        app_list = []
        for item, origin in zip(item_list, origin):
                    app_list.append((str(item) + ', ' + origin))
        
        prof['descOrigin'] = app_list
        
        def prof_type_changed():
            prof_type = dlg.comboBoxProfType.currentText()
            dlg.comboBoxBaseProfile.clear()

            prof_types = prof['descOrigin'][prof['ProfileType'] == prof_type]
            dlg.comboBoxBaseProfile.addItems(prof_types.tolist())
            dlg.comboBoxDay.setCurrentIndex(1)

        def day_changed():
            day = dlg.comboBoxDay.currentText()
            prof_type = dlg.comboBoxProfType.currentText()
            dlg.comboBoxBaseProfile.clear()

            prof_types_d = prof[prof['ProfileType'] == prof_type]
            prof_types_d = prof_types_d['descOrigin'][prof['Day'] == day]

            dlg.comboBoxBaseProfile.addItems(prof_types_d.tolist())
            dlg.comboBoxBaseProfile.setEnabled(True)

        def base_prof_changed():
            base_prof = dlg.comboBoxBaseProfile.currentText()
            prof_sel = prof[prof['descOrigin'] == base_prof]
            prof_sel.columns = prof_sel.columns.map(str)
            prof_sel_dict = prof_sel.squeeze().to_dict()


            for i in range(0,24):
                Tb = eval('dlg.textBrowser_' + str(i))
                Le = eval('dlg.lineEdit_' + str(i))
                Le.clear()
                Le.setText(str(prof_sel_dict[str(Tb.toPlainText())]))

        def show_references():
            ref_list = []
            for i in range(len(ref)):
                ref_list.append(str(ref['Author'].iloc[i]) + ' (' + str(ref['Publication Year'].iloc[i]) + ')')
            ref['authoryear'] = ref_list
            dlg.comboBoxRef.addItems(sorted(ref_list)) 
            dlg.comboBoxRef.setCurrentIndex(-1)
        
        show_references()
        
        def ref_changed():
            dlg.textBrowserRef.clear()

            try:
                ID = ref[ref['authoryear'] ==  dlg.comboBoxRef.currentText()].index.item()
                dlg.textBrowserRef.setText(
                    '<b>Author: ' +'</b>' + str(ref.loc[ID, 'Author']) + '<br><br><b>' +
                    'Year: ' + '</b> '+ str(ref.loc[ID, 'Publication Year']) + '<br><br><b>' +
                    'Title: ' + '</b> ' +  str(ref.loc[ID, 'Title']) + '<br><br><b>' +
                    'Journal: ' + '</b>' + str(ref.loc[ID, 'Journal']) + '<br><br><b>'
                )
            except:
                pass

        dlg.comboBoxRef.currentIndexChanged.connect(ref_changed) 
        dlg.comboBoxProfType.currentIndexChanged.connect(prof_type_changed)
        dlg.comboBoxBaseProfile.currentIndexChanged.connect(base_prof_changed)
        dlg.comboBoxDay.currentIndexChanged.connect(day_changed)


    #################################################################################################
    #                                                                                               #
    #                                  Irrigation manager                                           #
    #                                                                                               #
    #################################################################################################

    def setup_irrigation_manager(self, dlg):

        db_path = self.plugin_dir + '/database_copy.xlsx'  
        ref = pd.read_excel(db_path, sheet_name = 'References', index_col = 'ID', engine = 'openpyxl')
        irr = pd.read_excel(db_path, sheet_name = 'Lod3_Irrigation', index_col = 'ID', engine = 'openpyxl')

        item_list = irr['Description'].tolist()
        origin = irr['Origin'].tolist()

        app_list = []
        for item, origin in zip(item_list, origin):
                    app_list.append((item + ', ' + origin))
        
        irr['descOrigin'] = app_list
        
        dlg.comboBoxBaseIrr.addItems(irr['descOrigin'].tolist())
        dlg.comboBoxBaseIrr.setCurrentIndex(-1)

        def base_irr_changed():

            base_irr = dlg.comboBoxBaseIrr.currentText()
            irr_sel = irr[irr['descOrigin'] == base_irr]

            irr_sel_dict = irr_sel.squeeze().to_dict()

            for i in range(0,25):
                Tb = eval('dlg.textBrowser_' + str(i))
                Le = eval('dlg.IrrLineEdit_' + str(i))
                Le.clear()
                Le.setText(str(irr_sel_dict[Tb.toPlainText()]))


        def show_references():
            ref_list = []
            for i in range(len(ref)):
                ref_list.append(str(ref['Author'].iloc[i]) + ' (' + str(ref['Publication Year'].iloc[i]) + ')')
            ref['authoryear'] = ref_list
            dlg.comboBoxRef.addItems(sorted(ref_list)) 
            dlg.comboBoxRef.setCurrentIndex(-1)
        
        show_references()
        
        def ref_changed():
            dlg.textBrowserRef.clear()
            try:
                ID = ref[ref['authoryear'] ==  dlg.comboBoxRef.currentText()].index.item()
                dlg.textBrowserRef.setText(
                    '<b>Author: ' +'</b>' + str(ref.loc[ID, 'Author']) + '<br><br><b>' +
                    'Year: ' + '</b> '+ str(ref.loc[ID, 'Publication Year']) + '<br><br><b>' +
                    'Title: ' + '</b> ' +  str(ref.loc[ID, 'Title']) + '<br><br><b>' +
                    'Journal: ' + '</b>' + str(ref.loc[ID, 'Journal']) + '<br><br><b>'
                )
            except:
                pass

        dlg.comboBoxRef.currentIndexChanged.connect(ref_changed) 
        dlg.comboBoxBaseIrr.currentIndexChanged.connect(base_irr_changed)


    #################################################################################################
    #                                                                                               #
    #                                  Reference manager                                            #
    #                                                                                               #
    #################################################################################################

    def setup_ref_manager(self, dlg):
        

        def check_reference():

            dlg.pushButtonAddRef.setEnabled(True)
            author_list = []
            for i in range(0,16):
                first_name = eval('dlg.textEditFN_' + str(i))
                last_name = eval('dlg.textEditLN0_' + str(i))   
                name = first_name.value() + ', ' + last_name.value() + ';' 
                if len(first_name.value()) > 0 and len(last_name.value()) > 0: 
                    author_list.append(name)
            
            ref_dict = {
                'Author' : (' '.join(author_list)),
                'Publication Year' : dlg.textEditYear.value(),
                'Title' : dlg.textEditTitle.value(),
                'Journal' : dlg.textEditJournal.value(),
                'DOI' : dlg.textEditDOI.value()
            }

            QMessageBox.information(None, 'Sucessful','Your reference is compatible. \n Press Add Refernce to add to your Local Database')

        def add_reference():

            Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()
            author_list = []
            for i in range(0,16):
                first_name = eval('dlg.textEditFN_' + str(i))
                last_name = eval('dlg.textEditLN0_' + str(i))   
                name = first_name.value() + ', ' + last_name.value() + ';' 
                if len(first_name.value()) > 0 and len(last_name.value()) > 0: 
                    author_list.append(name)
            
            ref_dict = {
                'ID' : 'Ref' + str(int(round(time.time()))),
                'Author' : (' '.join(author_list)),
                'Publication Year' : dlg.textEditYear.value(),
                'Title' : dlg.textEditTitle.value(),
                'Journal' : dlg.textEditJournal.value(),
                'DOI' : dlg.textEditDOI.value()
            }
            
            new_edit_ref = pd.DataFrame(ref_dict, index=[0]).set_index('ID')

            ref = ref.append(new_edit_ref)
            self.write_to_db(Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            QMessageBox.information(None, 'Sucessful','Reference Added')

  
        dlg.pushButtonCheck.clicked.connect(check_reference)
        dlg.pushButtonAddRef.clicked.connect(add_reference)
        dlg.pushButtonAddRef.clicked.connect(self.reset_ref_manager)

            # dict_reclass = {
            #     'ID' : 'Ref' + str(int(round(time.time()))),
            #     # 'Author' : dlg.textEditRefAuthor.value(),
            #     'Title' : dlg.textEditTitle.value(),
            #     'Publication Year' : dlg.textEditYear.value(),
            #     'Journal' : dlg.textEditJournal.value(),
            # }

            # new_edit_ref = pd.DataFrame(dict_reclass, index=[0]).set_index('ID')

            # ref = ref.append(new_edit_ref)
            
            # self.write_to_db(Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            # QMessageBox.information(None, 'Sucessful','Reference Added')

    
        

    #######################################################################################################################################
    #######################################################################################################################################
    #######################################################################################################################################
    #######################################################################################################################################
    def read_db(self):
        db_path = self.plugin_dir + '/database_copy.xlsx'  
        idx_col = 'ID'
        # Lod 1
        Type = pd.read_excel(db_path, sheet_name = 'Lod1_Types', index_col=  idx_col, engine = 'openpyxl')
        Type.name = 'Lod1_Types'
        # Lod 2
        veg = pd.read_excel(db_path, sheet_name = 'Lod2_Veg', index_col = idx_col, engine = 'openpyxl')
        veg.name = 'Lod2_Veg'
        nonveg = pd.read_excel(db_path, sheet_name = 'Lod2_NonVeg', index_col = idx_col, engine = 'openpyxl')
        nonveg.name = 'Lod2_NonVeg'
        water = pd.read_excel(db_path, sheet_name = 'Lod2_Water', index_col = idx_col, engine = 'openpyxl')
        water.name = 'Lod2_Water'
        # Ref
        ref = pd.read_excel(db_path, sheet_name = 'References', index_col = idx_col, engine = 'openpyxl')
        ref.name = 'References'
        # Lod 3
        alb =  pd.read_excel(db_path, sheet_name = 'Lod3_Albedo', index_col = idx_col, engine = 'openpyxl')
        alb.name = 'Lod3_Albedo'
        em =  pd.read_excel(db_path, sheet_name = 'Lod3_Emissivity', index_col = idx_col, engine = 'openpyxl')
        em.name = 'Lod3_Emissivity'
        OHM =  pd.read_excel(db_path, sheet_name = 'Lod3_OHM', index_col = idx_col, engine = 'openpyxl') # Away from Veg
        OHM.name = 'Lod3_OHM'
        LAI =  pd.read_excel(db_path, sheet_name = 'Lod3_LAI', index_col = idx_col, engine = 'openpyxl')
        LAI.name = 'Lod3_OHM'
        st = pd.read_excel(db_path, sheet_name = 'Lod3_Storage', index_col = idx_col, engine = 'openpyxl')
        st.name = 'Lod3_Storage'
        cnd = pd.read_excel(db_path, sheet_name = 'Lod3_Conductance', index_col = idx_col, engine = 'openpyxl') # Away from Veg
        cnd.name = 'Lod3_Conductance'
        LGP = pd.read_excel(db_path, sheet_name = 'Lod3_LGP', index_col = idx_col, engine = 'openpyxl')
        LGP.name = 'Lod3_LGP'
        dr = pd.read_excel(db_path, sheet_name = 'Lod3_Drainage', index_col = idx_col, engine = 'openpyxl')
        dr.name = 'Lod3_Drainage'
        VG = pd.read_excel(db_path, sheet_name = 'Lod3_VegetationGrowth', index_col = idx_col, engine = 'openpyxl')
        VG.name = 'Lod3_VegetationGrowth'
        ANOHM = pd.read_excel(db_path, sheet_name = 'Lod3_ANOHM', index_col = idx_col, engine = 'openpyxl')
        ANOHM.name = 'Lod3_ANOHM'
        BIOCO2 = pd.read_excel(db_path, sheet_name = 'Lod3_BiogenCO2',index_col = idx_col, engine = 'openpyxl')
        BIOCO2.name = 'Lod3_BiogenCO2'
        MVCND = pd.read_excel(db_path, sheet_name= 'Lod3_MaxVegetationConductance', index_col = idx_col, engine = 'openpyxl')
        MVCND.name = 'Lod3_MaxVegetationConductance'
        por = pd.read_excel(db_path, sheet_name = 'Lod3_Porosity', index_col = idx_col, engine = 'openpyxl')
        por.name = 'Lod3_Porosity'
        
        return Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por

    def read_suews_db(self):

        # set path to our read the docs

        db_path = self.plugin_dir + '/SUEWS_db.xlsx'  
        idx_col = 'ID'
        # Lod 1
        suews_Type = pd.read_excel(db_path, sheet_name = 'Lod1_Types', index_col=  idx_col, engine = 'openpyxl')
        # Lod 2
        suews_veg = pd.read_excel(db_path, sheet_name = 'Lod2_Veg', index_col = idx_col, engine = 'openpyxl')
        suews_veg.name = 'Lod2_Veg'
        suews_nonveg = pd.read_excel(db_path, sheet_name = 'Lod2_NonVeg', index_col = idx_col, engine = 'openpyxl')
        suews_nonveg.name = 'Lod2_NonVeg'
        suews_water = pd.read_excel(db_path, sheet_name = 'Lod2_Water', index_col = idx_col, engine = 'openpyxl')
        suews_water.name = 'Lod2_Water'
        # Ref
        suews_ref = pd.read_excel(db_path, sheet_name = 'References', index_col = idx_col, engine = 'openpyxl')
        # Lod 3
        suews_alb =  pd.read_excel(db_path, sheet_name = 'Lod3_Albedo', index_col = idx_col, engine = 'openpyxl')
        suews_alb.name = 'Lod3_Albedo'
        suews_em =  pd.read_excel(db_path, sheet_name = 'Lod3_Emissivity', index_col = idx_col, engine = 'openpyxl')
        suews_em.name = 'Lod3_Emissivity'
        suews_OHM =  pd.read_excel(db_path, sheet_name = 'Lod3_OHM', index_col = idx_col, engine = 'openpyxl') # Away from Veg
        suews_OHM.name = 'Lod3_OHM'
        suews_LAI =  pd.read_excel(db_path, sheet_name = 'Lod3_LAI', index_col = idx_col, engine = 'openpyxl')
        suews_LAI.name = 'Lod3_OHM'
        suews_st = pd.read_excel(db_path, sheet_name = 'Lod3_Storage', index_col = idx_col, engine = 'openpyxl')
        suews_st.name = 'Lod3_Storage'
        suews_cnd = pd.read_excel(db_path, sheet_name = 'Lod3_Conductance', index_col = idx_col, engine = 'openpyxl') # Away from Veg
        suews_cnd.name = 'Lod3_Conductance'
        suews_LGP = pd.read_excel(db_path, sheet_name = 'Lod3_LGP', index_col = idx_col, engine = 'openpyxl')
        suews_LGP.name = 'Lod3_LGP'
        suews_dr = pd.read_excel(db_path, sheet_name = 'Lod3_Drainage', index_col = idx_col, engine = 'openpyxl')
        suews_dr.name = 'Lod3_Drainage'
        suews_VG = pd.read_excel(db_path, sheet_name = 'Lod3_VegetationGrowth', index_col = idx_col, engine = 'openpyxl')
        suews_VG.name = 'Lod3_VegetationGrowth'
        suews_ANOHM = pd.read_excel(db_path, sheet_name = 'Lod3_ANOHM', index_col = idx_col, engine = 'openpyxl')
        suews_ANOHM.name = 'Lod3_ANOHM'
        suews_BIOCO2 = pd.read_excel(db_path, sheet_name = 'Lod3_BiogenCO2',index_col = idx_col, engine = 'openpyxl')
        suews_BIOCO2.name = 'Lod3_BiogenCO2'
        suews_MVCND = pd.read_excel(db_path, sheet_name= 'Lod3_MaxVegetationConductance', index_col = idx_col, engine = 'openpyxl')
        suews_MVCND.name = 'Lod3_MaxVegetationConductance'
        suews_por = pd.read_excel(db_path, sheet_name = 'Lod3_Porosity', index_col = idx_col, engine = 'openpyxl')
        suews_por.name = 'Lod3_Porosity'
        
        return suews_Type, suews_veg, suews_nonveg, suews_water, suews_ref, suews_alb, suews_em, suews_OHM, suews_LAI, suews_st, suews_cnd, suews_LGP, suews_dr,suews_VG, suews_ANOHM, suews_BIOCO2, suews_MVCND, suews_por

    def write_to_db(self,Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por):

            db_path = self.plugin_dir + '/database_copy.xlsx'  
            writer = pd.ExcelWriter(db_path)

            Type.to_excel(writer, sheet_name = 'Lod1_Types')
            veg.to_excel(writer, sheet_name = 'Lod2_Veg')
            nonveg.to_excel(writer, sheet_name = 'Lod2_NonVeg')
            water.to_excel(writer, sheet_name = 'Lod2_Water')
            ref.to_excel(writer, sheet_name = 'References')
            alb.to_excel(writer, sheet_name = 'Lod3_Albedo')
            em.to_excel(writer, sheet_name = 'Lod3_Emissivity')
            OHM.to_excel(writer, sheet_name = 'Lod3_OHM')
            LAI.to_excel(writer, sheet_name = 'Lod3_LAI')
            st.to_excel(writer, sheet_name = 'Lod3_Storage')
            cnd.to_excel(writer, sheet_name = 'Lod3_Conductance')
            LGP.to_excel(writer, sheet_name = 'Lod3_LGP')
            dr.to_excel(writer, sheet_name = 'Lod3_Drainage')
            VG.to_excel(writer, sheet_name = 'Lod3_VegetationGrowth')
            ANOHM.to_excel(writer, sheet_name = 'Lod3_ANOHM')
            BIOCO2.to_excel(writer, sheet_name = 'Lod3_BiogenCO2')
            MVCND.to_excel(writer, sheet_name = 'Lod3_MaxVegetationConductance')
            por.to_excel(writer, sheet_name = 'Lod3_Porosity')

            writer.save()


    def get_dicts(self,veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por):
        

        # FIX THESE DICTS!
        table_dict = {
            'Type' : 'Lod1_Types',
            'Ref' :'References', 
            'Veg' : 'Lod2_Veg',
            'NonVeg' : 'Lod2_NonVeg',
            'Water' : 'Lod2_Water',
            'Emissivity': 'Lod3_Emissivity',
            'OHM': 'Lod3_OHM',
            'Albedo': 'Lod3_Albedo',
            'Leaf Area Index': 'Lod3_LAI',
            'Water Storage': 'Lod3_Storage',
            'Conductance': 'Lod3_Conductance',
            'Leaf Growth Power': 'Lod3_LGP',
            'Drainage': 'Lod3_Drainage',
            'Vegetation Growth' : 'Lod3_VegetationGrowth',
            'ANOHM' : 'Lod3_ANOHM',
            'Biogen CO2' : 'Lod3_BiogenCO2',
            'Max Vegetation Conductance' : 'Lod3_MaxVegetationConductance',
            'Porosity' : 'Lod3_Porosity'
        }
            
        table_dict_ID = {
            'Emissivity': 'Em',
            'OHM': 'OHM',
            'Albedo': 'Alb',
            'Leaf Area Index': 'LAI',
            'Water Storage': 'St',
            'Conductance': 'Cnd',
            'Leaf Growth Power': 'LGP',
            'Drainage': 'Dr',
            'OHM Summer Wet': 'OHMSummerWet' ,	
            'OHM Summer Dry': 'OHMSummerDry',
            'OHM Winter Wet': 'OHMWinterWet',
            'OHM Winter Dry': 'OHMWinterDry',
            'Vegetation Growth' : 'VG',
            'ANOHM' : 'ANOHM',
            'BIOCO2' : 'BIOCO2',
            'Max Vegetation Conductance' : 'MVCND',
            'Porosity' : 'Por',
            'Evergreen Tree' : 'Veg',
            'Decidous Tree' : 'Veg',
            'Grass' : 'Veg',
            'Building' : 'NonVeg',
            'Paved' : 'NonVeg',
            'Bare Soil': 'Bsoil',
            'Water' : 'Water'}

        table_dict_pd = {
            'Emissivity': em,
            'OHM': OHM,
            'OHM Summer Wet': OHM ,	
            'OHM Summer Dry': OHM ,
            'OHM Winter Wet': OHM ,
            'OHM Winter Dry': OHM ,
            'Albedo': alb,
            'Leaf Area Index': LAI,
            'Water Storage': st,
            'Conductance': cnd,
            'Leaf Growth Power': LGP,
            'Drainage': dr,
            'Vegetation Growth' : VG,
            'ANOHM' : ANOHM,
            'Biogen CO2' : BIOCO2,
            'Max Vegetation Conductance' : MVCND,
            'Porosity' : por,
            'Evergreen Tree' : veg,
            'Decidous Tree' : veg,
            'Grass' : veg,
            'Building' : nonveg,
            'Paved' : nonveg,
            'Bare Soil' : nonveg,
            'Water' : water
            }

        dict_str_var = {
            'Em': em,
            'OHM': OHM,
            'Alb': alb,
            'LAI': LAI,
            'St': st,
            'Cnd': cnd,
            'LGP': LGP,
            'Dr': dr
            
            }
        
        dict_gen_type = {
            'Paved' : 'NonVeg',
            'Building' : 'NonVeg',
            'Evergreen Tree' : 'Veg',
            'Decidous Tree' : 'Veg',
            'Grass' : 'Veg',
            'Bare Soil' : 'NonVeg',
            'Water' : 'Water', # WATER            
        }
        
        return table_dict,table_dict_ID,table_dict_pd,dict_str_var, dict_gen_type

    def reset_DB_editor(self):
        self.setup_tabs()
        self.dlg.tabWidget.setCurrentIndex(3)

    def reset_ref_manager(self):
        self.setup_tabs()
        self.dlg.tabWidget.setCurrentIndex(5)

    def run(self):
        '''Run method that performs all the real work'''

        self.setup_tabs()
       # Show the dialog
        self.dlg.show()

        #run the dialog event loop
        result = self.dlg.exec_()

        # See if OK was pressed
        if result:
            print('result')
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
        else:
            self.dlg.__init__()

    #     # Create the dialog with elements (after translation) and keep reference
    #     # Only create GUI ONCE in callback, so that it will only load when the plugin is started
    #     if self.first_start == True:
    #         self.first_start = False
    #         self.dlg = Urban_type_creatorDialog()

 

        # pixmap = QPixmap(r'C:\Script\NGEO306\urban_type_creator\image.JPG')

#            pixmap = QPixmap(r'C:\Script\NGEO306\urban_type_creator\image.JPG')
            # pixmap_rescaled = pixmap.scaled(100,100, QtCore.Qt.KeepAspectRatio) +
            # pixmap_rescaled.show()
        #)

        # '<img src='+r'C:\Script\NGEO306\urban_type_creator\image.JPG' + ' width='500' height=Auto>' 

    #    # Show the dialog
    #     self.dlg.show()

    #     #run the dialog event loop
    #     result = self.dlg.exec_()

    #     # See if OK was pressed
    #     if result:
    #         print('result')
    #         # Do something useful here - delete the line containing pass and
    #         # substitute with your code.
    #         pass
    #     else:
    #         self.dlg.__init__()



    

    # # Info Button
    # def typeInfo(self): 
       
    #     print('hej')

    #     self.dlg.Qlabel.clear()
    #     # self.dlg.Qlabel.clear()
    #     db_path = self.plugin_dir + '/database_copy.xlsx'

    #     # db = pd.read_csv(r'C:\Script\NGEO306\GHSL\UrbanTypes.txt', sep= '\t')
    #     db = pd.read_excel(db_path, sheet_name= 'Lod1_Types', index_col=  'ID')

    #     type_list = []
    #     for i in range(len(db)):
    #         type_list.append(str(db['Type'].iloc[i]) + ', ' + str(db['Location'].iloc[i]))
    #     db['type_location'] = type_list

        
    #     urb_type = dlg.comboBoxTableSelect.currentText() 
    #     selection = db.loc[db['type_location'] == urb_type]
        
    #     if len(urb_type)>0:
    #         dlg_.textBrowser.setText(
    #             'Urban Type Info: '+ selection['Type'].item() +
    #             '\n\nLocation: ' +  selection['Location'].item() +
    #             '\n\nPeriod: ' + str(selection['Period'].item()) + 
    #             '\n\nDescription: ' + str(selection['Description'].item()) +
    #             '\n\nAuthor: ' + str(selection['Author'].item())
    #             )
    #         try:
    #             url = str(selection['Url'].item())
            
    #             data = urllib.request.urlopen(url).read()
    #             pixmap = QPixmap()
    #             pixmap.loadFromData(data)
    #             dlg.Qlabel.setPixmap(pixmap.scaled(500,700, QtCore.Qt.KeepAspectRatio))
    #         except:
    #             dlg.Qlabel.setText('No reference Image avalible for this Type')

    #     else:
    #         QMessageBox.information(None, 'Error', 'No Type Selected')

    # def resetPlugin(self):
    #     self.layerComboManagerPointField.clear()
    #     self.layerComboManagerPoint.clear()
    #     self.dlg.comboBoxVector.clear()
    #     self.dlg.comboBoxField.clear()
    #     self.dlg.comboBoxField.setCurrentIndex(-1)
    #     self.dlg.textBrowser.clear()
    #     self.dlg.textOutput.clear()

    #     for i in range(1,14):
    #         Ls = eval('self.dlg.comboBoxClass' + str(i))
    #         Ls.clear()
    #         vars()['self.dlg.comboBoxClass' + str(i)] = Ls

    #         Rs = eval('self.dlg.comboBoxNew' + str(i))
    #         Rs.clear()
    #         vars()['self.dlg.comboBoxNew' + str(i)] = Rs


    def closeEvent(self, event):
        self.reset_form()
        self.resetPlugin()


# # -*- coding: utf-8 -*-
# '''
# /***************************************************************************
#  Urban_type_creator
#                                  A QGIS plugin
#  This plugin prepare suews lib data
#  Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
#                               -------------------
#         begin                : 2021-05-20
#         git sha              : $Format:%H$
#         copyright            : (C) 2021 by GU
#         email                : oskar.backlin@gu.se
#  ***************************************************************************/

# /***************************************************************************
#  *                                                                         *
#  *   This program is free software; you can redistribute it and/or modify  *
#  *   it under the terms of the GNU General Public License as published by  *
#  *   the Free Software Foundation; either version 2 of the License, or     *
#  *   (at your option) any later version.                                   *
#  *                                                                         *
#  ***************************************************************************/
# '''
# from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
# from qgis.PyQt.QtGui import QIcon, QPixmap
# from qgis.PyQt.QtWidgets import QFileDialog, QAction, QMessageBox
# from qgis.gui import QgsMapLayerComboBox, QgsFieldComboBox, QgsMessageBar
# from qgis.core import QgsVectorLayer, QgsMapLayerProxyModel, Qgis, QgsProject, QgsFieldProxyModel, QgsField
# # from ..urban_type_edior.urban_type_edior import urban_type_editor
# # Initialize Qt resources from file resources.py
# from .resources import *
# from pathlib import Path
# import geopandas as gpd
# import webbrowser
# import pandas as pd
# from timezonefinder import TimezoneFinder as tf
# import urllib
# import time


# # Import the code for the dialog
# from .Urban_type_creator_dialog import Urban_type_creatorDialog
# import os.path


# class Urban_type_creator(object):
#     '''QGIS Plugin Implementation.'''

#     def __init__(self, iface):
#         print('__init__')
#         '''Constructor.

#         :param iface: An interface instance that will be passed to this class
#             which provides the hook by which you can manipulate the QGIS
#             application at run time.
#         :type iface: QgsInterface
#         '''
#         # Save reference to the QGIS interface
#         self.iface = iface
#         # initialize plugin directory
#         self.plugin_dir = os.path.dirname(__file__)
#         # initialize locale
#         locale = QSettings().value('locale/userLocale')[0:2]
#         locale_path = os.path.join(
#             self.plugin_dir,
#             'i18n',
#             'Urban_type_creator_{}.qm'.format(locale))

#         if os.path.exists(locale_path):
#             self.translator = QTranslator()
#             self.translator.load(locale_path)
#             QCoreApplication.installTranslator(self.translator)

#         # Declare instance attributes
#         self.actions = []
#         self.menu = self.tr(u'&Urban_type_creator')

#         self.dlg = Urban_type_creatorDialog()
#         # Check if plugin was started the first time in current QGIS session
#         # Must be set in initGui() to survive plugin reloads
#         self.first_start = None

#         # Declare Variables
#         self.outputfile = None

       


#     # noinspection PyMethodMayBeStatic
#     def tr(self, message):
#         '''Get the translation for a string using Qt translation API.

#         We implement this ourselves since we do not inherit QObject.

#         :param message: String for translation.
#         :type message: str, QString

#         :returns: Translated version of message.
#         :rtype: QString
#         '''
#         # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
#         return QCoreApplication.translate('Urban_type_creator', message)


#     def add_action(
#         self,
#         icon_path,
#         text,
#         callback,
#         enabled_flag=True,
#         add_to_menu=True,
#         add_to_toolbar=True,
#         status_tip=None,
#         whats_this=None,
#         parent=None):
#         '''Add a toolbar icon to the toolbar.

#         :param icon_path: Path to the icon for this action. Can be a resource
#             path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
#         :type icon_path: str

#         :param text: Text that should be shown in menu items for this action.
#         :type text: str

#         :param callback: Function to be called when the action is triggered.
#         :type callback: function

#         :param enabled_flag: A flag indicating if the action should be enabled
#             by default. Defaults to True.
#         :type enabled_flag: bool

#         :param add_to_menu: Flag indicating whether the action should also
#             be added to the menu. Defaults to True.
#         :type add_to_menu: bool

#         :param add_to_toolbar: Flag indicating whether the action should also
#             be added to the toolbar. Defaults to True.
#         :type add_to_toolbar: bool

#         :param status_tip: Optional text to show in a popup when mouse pointer
#             hovers over the action.
#         :type status_tip: str

#         :param parent: Parent widget for the new action. Defaults None.
#         :type parent: QWidget

#         :param whats_this: Optional text to show in the status bar when the
#             mouse pointer hovers over the action.

#         :returns: The action that was created. Note that the action is also
#             added to self.actions list.
#         :rtype: QAction
#         '''

#         icon = QIcon(icon_path)
#         action = QAction(icon, text, parent)
#         action.triggered.connect(callback)
#         action.setEnabled(enabled_flag)

#         if status_tip is not None:
#             action.setStatusTip(status_tip)

#         if whats_this is not None:
#             action.setWhatsThis(whats_this)

#         if add_to_toolbar:
#             # Adds plugin icon to Plugins toolbar
#             self.iface.addToolBarIcon(action)

#         if add_to_menu:
#             self.iface.addPluginToMenu(
#                 self.menu,
#                 action)

#         self.actions.append(action)

#         return action

#     def initGui(self):
#         print('init_GUI')
#         '''Create the menu entries and toolbar icons inside the QGIS GUI.'''

#         icon_path = ':/plugins/Urban_type_creator/icon.png'
#         self.add_action(
#             icon_path,
#             text=self.tr(u''),
#             callback=self.run,
#             parent=self.iface.mainWindow())

#         # will be set False in run()
#         self.first_start = False


#     def unload(self):
#         '''Removes the plugin menu item and icon from QGIS GUI.'''
#         for action in self.actions:
#             self.iface.removePluginMenu(
#                 self.tr(u'&Urban_type_creator'),
#                 action)
#             self.iface.removeToolBarIcon(action)


#     def run(self):
#         print('run')
#         '''Run method that performs all the real work'''

#         # Create the dialog with elements (after translation) and keep reference
#         # Only create GUI ONCE in callback, so that it will only load when the plugin is started
#         if self.first_start == True:
#             self.first_start = False
#             self.dlg = Urban_type_creatorDialog()

#        # Use or not ? 
        
#         self.dlg.comboBoxField.clear()
#         self.dlg.comboBoxField.setCurrentIndex(-1)
#         self.dlg.comboBoxField.setDisabled(True)
#         self.dlg.comboBoxTableSelect.clear()
#         self.dlg.textBrowser.clear()
#         self.dlg.textOutput.clear()
#         self.dlg.Qlabel.clear()
        
#         self.layerComboManagerPoint = self.dlg.comboBoxVector
#         self.layerComboManagerPoint.setCurrentIndex(-1)
#         self.layerComboManagerPoint.setFilters(QgsMapLayerProxyModel.PolygonLayer)
#         #self.layerComboManagerPoint.setFixedWidth(250)

#         self.layerComboManagerPointField = self.dlg.comboBoxField
#         self.layerComboManagerPointField.setFilters(QgsFieldProxyModel.AllTypes)
#         # self.layerComboManagerPointField.setFixedWidth(250)
#         self.layerComboManagerPoint.layerChanged.connect(self.layerComboManagerPointField.setLayer)
#         self.layerComboManagerPointField.setEnabled(True)
#         # tf().timezone_at(lng=x, lat=y)

#         # x = vectorlayer.to_crs('EPSG:4326').loc[0:0].representative_point().x.item()
#         # y = vectorlayer.to_crs('EPSG:4326').loc[0:0].representative_point().y.item()
        
#         # Set up for the Help button
#         self.dlg.helpButton_2.clicked.connect(self.typeInfo)

#         # Set up for the run button
#         self.dlg.runButton.clicked.connect(self.start_progress)

#         self.dlg.comboBoxField.fieldChanged.connect(self.field_changed) 

#          # Set up of file save dialog
#         self.fileDialog = QFileDialog()
#         self.dlg.pushButtonSave.clicked.connect(self.savefile)



#         # Read Database 
#  #       db = pd.read_csv(r'C:\Script\NGEO306\GHSL\UrbanTypes.txt', sep= '\t')
#         db_path =r'C:\Script\NGEO306\database_copy.xlsx'
#         db = pd.read_excel(db_path, sheet_name= 'Lod1_Types', index_col=  'ID')

#         type_list = []
#         for i in range(len(db)):
#             type_list.append(str(db['Type'].iloc[i]) + ', ' + str(db['Location'].iloc[i]))
#         db['type_location'] = type_list

#         self.dlg.comboBoxTableSelect.addItems(sorted(type_list)) 
#         self.dlg.comboBoxTableSelect.setCurrentIndex(-1)

#         for i in range(1,14):
#             Ls = eval('self.dlg.comboBoxClass' + str(i))
#             Ls.clear()
#             vars()['self.dlg.comboBoxClass' + str(i)] = Ls

#             Rs = eval('self.dlg.comboBoxNew' + str(i))
#             Rs.clear()
#             Rs.addItems(sorted(type_list))
#             Rs.setCurrentIndex(-1)
#             vars()['self.dlg.comboBoxNew' + str(i)] = Rs


        

#         # pixmap = QPixmap(r'C:\Script\NGEO306\urban_type_creator\image.JPG')

# #            pixmap = QPixmap(r'C:\Script\NGEO306\urban_type_creator\image.JPG')
#             # pixmap_rescaled = pixmap.scaled(100,100, QtCore.Qt.KeepAspectRatio) +
#             # pixmap_rescaled.show()
#         #)

#         # '<img src='+r'C:\Script\NGEO306\urban_type_creator\image.JPG' + ' width='500' height=Auto>' 

#        # Show the dialog
#         self.dlg.show()

#         #run the dialog event loop
#         result = self.dlg.exec_()

#         # See if OK was pressed
#         if result:
#             print('result')
#             # Do something useful here - delete the line containing pass and
#             # substitute with your code.
#             pass
#         else:
#             self.dlg.__init__()



#     def field_changed(self, field):
#         #get current layer
#         layer = self.layerComboManagerPoint.currentLayer()
#         # get index of the field
#         i = layer.fields().indexOf(field)
#         # get unique values
#         unique_values = layer.uniqueValues(i)    
#         #remove all values from comboBoxAttribute

#         len_uv = len(unique_values)

#         # Set set to string. ComboBox does not accept other than string ATM
#         # Have not yet found a way to fix this. 
#         # this loop will do the trick as workaround

#         if isinstance(unique_values, str):
#             att_list = unique_values
#         else:
#             att_list = []
#             for i in unique_values:
#                 att_list.append(str(i))

#         for i in range(1,14):
#             # Oc == Old Class
#             Oc = eval('self.dlg.comboBoxClass' + str(i))
#             Oc.clear()
#             Oc.setDisabled(True)
#             vars()['self.dlg.comboBoxClass' + str(i)] = Oc

#             Nc = eval('self.dlg.comboBoxNew' + str(i))
#             Nc.setDisabled(True)
#             Nc.setCurrentIndex(-1)
#             vars()['self.dlg.comboBoxNew' + str(i)] = Nc

#             # Te = eval('self.dlg.editClassButton_' + str(i))
#             # Te.setDisabled(True)
#             # vars()['self.dlg.editClassButton_' + str(i)] = Te

#         idx = 1
#         for i in range(len_uv):
#             if idx > 13:
#                 break 
#             # Left side
#             Oc = eval('self.dlg.comboBoxClass' + str(idx))
#             #Oc.setEnabled(True)
#             Oc.addItems(att_list)
#             Oc.setCurrentIndex(i)
#             vars()['self.dlg.comboBoxClass' + str(idx)] = Oc

#             Nc = eval('self.dlg.comboBoxNew' + str(idx))
#             Nc.setEnabled(True)
#             vars()['self.dlg.comboBoxNew' + str(idx)] = Nc


#             idx += 1    

#     # Info Button
#     def typeInfo(self): 
       
#             self.dlg.Qlabel.clear()
#             # self.dlg.Qlabel.clear()
#             db_path =r'C:\Script\NGEO306\database_copy.xlsx'

#             # db = pd.read_csv(r'C:\Script\NGEO306\GHSL\UrbanTypes.txt', sep= '\t')
#             db = pd.read_excel(db_path, sheet_name= 'Lod1_Types', index_col=  'ID')

#             type_list = []
#             for i in range(len(db)):
#                 type_list.append(str(db['Type'].iloc[i]) + ', ' + str(db['Location'].iloc[i]))
#             db['type_location'] = type_list

            
#             urb_type = self.dlg.comboBoxTableSelect.currentText() 
#             selection = db.loc[db['type_location'] == urb_type]
            
#             if len(urb_type)>0:
#                 self.dlg.textBrowser.setText(
#                     'Urban Type Info: '+ selection['Type'].item() +
#                     '\n\nLocation: ' +  selection['Location'].item() +
#                     '\n\nPeriod: ' + str(selection['Period'].item()) + 
#                     '\n\nDescription: ' + str(selection['Description'].item()) +
#                     '\n\nAuthor: ' + str(selection['Author'].item())
#                     )
#                 try:
#                     url = str(selection['Url'].item())
                
#                     data = urllib.request.urlopen(url).read()
#                     pixmap = QPixmap()
#                     pixmap.loadFromData(data)
#                     self.dlg.Qlabel.setPixmap(pixmap.scaled(500,700, QtCore.Qt.KeepAspectRatio))
#                 except:
#                     self.dlg.Qlabel.setText('No reference Image avalible for this Type')

#             else:
#                 QMessageBox.information(None, 'Error', 'No Type Selected')


#     def savefile(self):
#         self.outputfile = self.fileDialog.getSaveFileName(None, 'Save File As:', None, 'Shapefiles (*.shp)')
#         self.dlg.textOutput.setText(self.outputfile[0])

#     def help(self):
#         url = 'https://github.com/gusbacos/UTDB'
#         webbrowser.open_new_tab(url)

#     def start_progress(self):
#         print('in start_progress')

#         att_field =  self.layerComboManagerPointField.currentText()

#         vlayer = self.layerComboManagerPoint.currentLayer()

#         # Read Vectorlayer Path
#         gdf = gpd.read_file(str(vlayer.dataProvider().dataSourceUri()))

#         dict_reclass = {}

#         idx = 1
#         for i in range(len(set(gdf[att_field]))):
#             if idx > 13:
#                 break 
#             # Left side
#             Oc = eval('self.dlg.comboBoxClass' + str(idx))
#             oldField = Oc.currentText()
#             vars()['self.dlg.comboBoxClass' + str(idx)] = Oc
            
#             # Right Side
#             Nc = eval('self.dlg.comboBoxNew' + str(idx))
#             newField = Nc.currentText()
#             vars()['self.dlg.comboBoxNew' + str(idx)] = Nc
            
#             dict_reclass[str(oldField)] = str(newField)

#             idx += 1

#         print(dict_reclass)
     
#         # Backup not using GeoPandas ********
#         # vlayer_provider=vlayer.dataProvider()
#         # vlayer.dataProvider().addAttributes([QgsField('newfield',QVariant.String)])
#         # vlayer.updateFields()
#         # print (layer.fields().names())
#         # #layer = iface.activeLayer()
#         # newfieldindex = vlayer.fields().indexFromName('newfield') #The field needs to be created in advance
#         # attrmap = {} #dictionary of feature id: {field index: new value}
#         # for f in vlayer.getFeatures():
#         #     if f[field] in dict_reclass:
#         #         attrmap[f.id()] = {newfieldindex:dict_reclass[f[field]]}

#         # vlayer.dataProvider().changeAttributeValues(attrmap)

#         gdf['New_class'] = gdf[att_field].map(dict_reclass)

#         #print(gdf[[att_field,'New_class']].head())
#         gdf.to_file(self.outputfile[0])

#         vlayer = QgsVectorLayer(self.outputfile[0], Path(self.outputfile[0]).name[:-4])

#         QgsProject.instance().addMapLayer(vlayer)
#         QMessageBox.information(None, 'Process Complete', 'Your reclassified shapefile has been added to project')

        


#     def resetPlugin(self):
#         self.layerComboManagerPointField.clear()
#         self.layerComboManagerPoint.clear()
#         self.dlg.comboBoxVector.clear()
#         self.dlg.comboBoxField.clear()
#         self.dlg.comboBoxField.setCurrentIndex(-1)
#         self.dlg.textBrowser.clear()
#         self.dlg.textOutput.clear()

#         for i in range(1,14):
#             Ls = eval('self.dlg.comboBoxClass' + str(i))
#             Ls.clear()
#             vars()['self.dlg.comboBoxClass' + str(i)] = Ls

#             Rs = eval('self.dlg.comboBoxNew' + str(i))
#             Rs.clear()
#             vars()['self.dlg.comboBoxNew' + str(i)] = Rs


#     def closeEvent(self, event):
#         self.reset_form()
#         self.resetPlugin()