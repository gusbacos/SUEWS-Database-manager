# -*- coding: utf-8 -*-
'''
/***************************************************************************
 Suews_database_manager
                                 A QGIS plugin
 This plugin prepare suews lib data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-05-20
        git sha              : $Format:%H$
        copyright            : (C) 2021 by GU
        email                : oskar.backlin@gu.se
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
'''
from os import stat_result
from pandas.core.indexes import base
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon, QPixmap
from qgis.PyQt.QtWidgets import QFileDialog, QAction, QMessageBox
from qgis.gui import QgsMapLayerComboBox, QgsFieldComboBox, QgsMessageBar
from qgis.core import QgsVectorLayer, QgsMapLayerProxyModel, Qgis, QgsProject, QgsFieldProxyModel, QgsField
# Initialize Qt resources from file resources.py
from .tabs.urban_type_creator_tab import UrbanTypeCreator
from .tabs.urban_type_editor_tab import UrbanTypeEditor
from .tabs.urban_type_db_editor_tab import UrbanTypeDBEditor
from .tabs.urban_elements_creator_tab import UrbanElementsCreator
from .tabs.urban_ESTM import ESTM_creator
from .resources import *
from pathlib import Path
import geopandas as gpd
import webbrowser
import pandas as pd
import codecs

# from timezonefinder import TimezoneFinder as tf
import urllib
import time
import datetime
import re
import openpyxl
# import excelrd as xlrd # Possibly needed for python 3.2. perhaps not

# Import the code for the dialog
from .Urban_type_creator_dialog import Urban_type_creatorDialog
import os.path


class Urban_type_creator(object):
    '''QGIS Plugin Implementation.'''

    def __init__(self, iface):
        print('__init__')
        '''Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGISs
            application at run time.
        :type iface: QgsInterface
        '''
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Urban_type_creator_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Urban_type_creator')

        self.dlg = Urban_type_creatorDialog()
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Declare Variables
        self.outputfile = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        '''Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        '''
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Urban_type_creator', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        '''Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        '''

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        '''Create the menu entries and toolbar icons inside the QGIS GUI.'''

        icon_path = ':/plugins/Urban_type_creator/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = False

    def unload(self):
        '''Removes the plugin menu item and icon from QGIS GUI.'''
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Urban_type_creator'),
                action)
            self.iface.removeToolBarIcon(action)

    def setup_tabs(self):
        self.dlg.tabWidget.clear()

        urban_creator = UrbanTypeCreator()
        self.setup_urban_type_creator(urban_creator)
        self.dlg.tabWidget.addTab(urban_creator, 'Urban Type Classifier')

        urban_editor = UrbanTypeEditor()
        self.setup_urban_type_editor(urban_editor)
        self.dlg.tabWidget.addTab(urban_editor, 'Urban Type Editor')

        urban_elements_creator = UrbanElementsCreator()
        self.setup_urban_elements_creator(urban_elements_creator)
        self.dlg.tabWidget.addTab(urban_elements_creator, 'Urban Elements Creator')

        urban_db_editor = UrbanTypeDBEditor()
        self.setup_urban_db_type_editor(urban_db_editor)
        self.dlg.tabWidget.addTab(urban_db_editor, 'SUEWS Table Editor')

        estm_creator = ESTM_creator()
        self.setup_ESTM_creator(estm_creator)
        self.dlg.tabWidget.addTab(estm_creator, 'ESTM_Creator')

    #################################################################################################
    #                                                                                               #
    #                                     Urban Type Classifier                                     #
    #                                                                                               #
    #################################################################################################

    def setup_urban_type_creator(self, dlg):
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = UrbanTypeCreator()
        # dlg_ = UrbanTypeCreator()


        def layer_changed():
                layer = self.layerComboManagerPoint.currentLayer()
                att_list = list(layer.attributeAliases())
                try:
                    dlg.comboBoxField.clear()
                    dlg.comboBoxField.setEnabled(True)
                    dlg.comboBoxField.addItems(att_list)
                    dlg.comboBoxField.setCurrentIndex(0)

                    field_changed() 
                except:
                    pass
       
        def field_changed():

                layer = self.layerComboManagerPoint.currentLayer()
                att_list = list(layer.attributeAliases())
                try: 
                    att_column = dlg.comboBoxField.currentText()
                    att_index = att_list.index(att_column)
                    
                    unique_values = list(layer.uniqueValues(att_index))
                    len_uv = len(unique_values)

                    # Ensure always String 
                    unique_values = ([str(x) for x in unique_values])

                    for i in range(1,14):
                        # Oc == Old Class
                        Oc = eval('dlg.comboBoxClass' + str(i))
                        Oc.clear()
                        Oc.setDisabled(True)
                        vars()['dlg.comboBoxClass' + str(i)] = Oc
                        # Nc == New Class
                        Nc = eval('dlg.comboBoxNew' + str(i))
                        Nc.setCurrentIndex(-1)
                        Nc.setDisabled(True)
                        vars()['dlg.comboBoxNew' + str(i)] = Nc
                    
                    # Add Items to left side Comboboxes and enable right side comboboxes 
                    for i in range(len_uv):
                        idx = i+1
                        if idx > 13:
                            break 
                        Oc = eval('dlg.comboBoxClass' + str(idx))
                        Oc.addItems(unique_values)
                        Oc.setCurrentIndex(i)
                        vars()['dlg.comboBoxClass' + str(idx)] = Oc

                        Nc = eval('dlg.comboBoxNew' + str(idx))
                        Nc.setEnabled(True)
                        vars()['dlg.comboBoxNew' + str(idx)] = Nc
                except:
                    pass

        def typeInfo(): 

            dlg.textOutput.clear()
            dlg.Qlabel.clear()

            db_path = self.plugin_dir + '/database_copy.xlsx'
            db = pd.read_excel(db_path, sheet_name= 'Lod1_Types', index_col=  'ID', engine= 'openpyxl')

            type_list = []
            for i in range(len(db)):
                type_list.append(str(db['Type'].iloc[i]) + ', ' + str(db['Origin'].iloc[i]))
            db['type_Origin'] = type_list
          
            urb_type = dlg.comboBoxType.currentText() 
            selection = db.loc[db['type_Origin'] == urb_type]
            
            try:
                dlg.textBrowser.setText(
                    'Urban Type Info: '+ selection['Type'].item() +
                    '\n\nOrigin: ' +  selection['Origin'].item() +
                    '\n\nPeriod: ' + str(selection['Period'].item()) + 
                    '\n\nDescription: ' + str(selection['Description'].item()) +
                    '\n\nAuthor: ' + str(selection['Author'].item()) 
                    # '\n\nDate of Creation' + str(datetime.datetime.fromtimestamp(selection['ID'].item()).strftime('%Y-%m-%d %H:%M:%S'))
                    )
                # Test if reference picture exists
                try:
                    url = str(selection['Url'].item())
                    data = urllib.request.urlopen(url).read()
                    pixmap = QPixmap()
                    pixmap.loadFromData(data)
                    dlg.Qlabel.setPixmap(pixmap.scaled(500,700, QtCore.Qt.KeepAspectRatio))
                except:
                    dlg.Qlabel.setText('No reference Image avalible for this Type')
            except:
                pass

        def savefile():
            # Add possibilites to save as other format? Is .shp only format used in SUEWS Prepare?
            self.outputfile = self.fileDialog.getSaveFileName(None, 'Save File As:', None, 'Shapefiles (*.shp)')
            dlg.textOutput.setText(self.outputfile[0])

        def help():
            url = 'https://github.com/gusbacos/UTDB'
            # To readthedocs? 
            webbrowser.open_new_tab(url)

        def start_progress():
            att_field =  dlg.comboBoxField.currentText()

            vlayer = self.layerComboManagerPoint.currentLayer()

            # Read Vectorlayer Path
            gdf = gpd.read_file(str(vlayer.dataProvider().dataSourceUri()))

            dict_reclass = {}

            idx = 1
            for i in range(len(set(gdf[att_field]))):
                if idx > 13:
                    break 
                # Left side
                Oc = eval('dlg.comboBoxClass' + str(idx))
                oldField = Oc.currentText()
                vars()['dlg.comboBoxClass' + str(idx)] = Oc
                
                # Right Side
                Nc = eval('dlg.comboBoxNew' + str(idx))
                newField = Nc.currentText()
                vars()['dlg.comboBoxNew' + str(idx)] = Nc
                
                dict_reclass[str(oldField)] = str(newField)

                idx += 1

        
            # Backup not using GeoPandas

            # vlayer_provider=vlayer.dataProvider()
            # vlayer.dataProvider().addAttributes([QgsField('newfield',QVariant.String)])
            # vlayer.updateFields()
            # print (layer.fields().names())
            # #layer = iface.activeLayer()
            # newfieldindex = vlayer.fields().indexFromName('newfield') #The field needs to be created in advance
            # attrmap = {} #dictionary of feature id: {field index: new value}
            # for f in vlayer.getFeatures():
            #     if f[field] in dict_reclass:
            #         attrmap[f.id()] = {newfieldindex:dict_reclass[f[field]]}

            # vlayer.dataProvider().changeAttributeValues(attrmap)

            gdf['New_class'] = gdf[att_field].map(dict_reclass)

            gdf.to_file(self.outputfile[0])

            vlayer = QgsVectorLayer(self.outputfile[0], Path(self.outputfile[0]).name[:-4])

            QgsProject.instance().addMapLayer(vlayer)
            QMessageBox.information(None, 'Process Complete', 'Your reclassified shapefile has been added to project. Proceed to SUEWS-Preprare')
            dlg.textOutput.clear()
        
        self.layerComboManagerPoint = dlg.comboBoxVector
        self.layerComboManagerPoint.setCurrentIndex(-1)
        self.layerComboManagerPoint.setFilters(QgsMapLayerProxyModel.PolygonLayer)

        # Set up for the run button
        dlg.runButton.clicked.connect(start_progress)

        dlg.comboBoxVector.currentIndexChanged.connect(layer_changed)
        dlg.comboBoxField.currentIndexChanged.connect(field_changed) 

         # Set up of file save dialog
        self.fileDialog = QFileDialog()
        dlg.pushButtonSave.clicked.connect(savefile)

        # Read Database 
 #       db = pd.read_csv(r'C:\Script\NGEO306\GHSL\UrbanTypes.txt', sep= '\t')
        db_path = self.plugin_dir + '/database_copy.xlsx'
        db = pd.read_excel(db_path, sheet_name= 'Lod1_Types', index_col=  'ID', engine = 'openpyxl')

        type_list = []
        for i in range(len(db)):
            type_list.append(str(db['Type'].iloc[i]) + ', ' + str(db['Origin'].iloc[i]))
        db['type_Origin'] = type_list

        dlg.comboBoxType.addItems(sorted(type_list))
        dlg.comboBoxType.setCurrentIndex(-1) 

        for i in range(1,14):
            Ls = eval('dlg.comboBoxClass' + str(i))
            Ls.clear()
            vars()['dlg.comboBoxClass' + str(i)] = Ls

            Rs = eval('dlg.comboBoxNew' + str(i))
            Rs.clear()
            Rs.addItems(sorted(type_list))
            Rs.setCurrentIndex(-1)
            vars()['dlg.comboBoxNew' + str(i)] = Rs

        # Set type info when changing type
        dlg.comboBoxType.currentIndexChanged.connect(typeInfo)

    
    
    #################################################################################################
    #                                                                                               #
    #                                     Urban Type Editor                                         #
    #                                                                                               #
    #################################################################################################

    def setup_urban_type_editor(self, dlg):
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = urban_type_editorDialog()

        db_path = self.plugin_dir + '/database_copy.xlsx'  
        Type = pd.read_excel(db_path, sheet_name = 'Lod1_Types', index_col=  'ID', engine = 'openpyxl')
        veg = pd.read_excel(db_path, sheet_name = 'Lod2_Veg', index_col = 'ID', engine = 'openpyxl')
        nonveg = pd.read_excel(db_path, sheet_name = 'Lod2_NonVeg', index_col = 'ID', engine = 'openpyxl')
        water = pd.read_excel(db_path, sheet_name = 'Lod2_Water', index_col = 'ID', engine = 'openpyxl')

        # Add available types to combobox
        type_list = []
        for i in range(len(Type)):
            type_list.append(str(Type['Type'].iloc[i]) + ', ' + str(Type['Origin'].iloc[i]))
        Type['type_origin'] = type_list

        dlg.comboBoxTableSelect.addItems(sorted(type_list)) 
        dlg.comboBoxTableSelect.setCurrentIndex(-1)

        def check_type():

            db_path = self.plugin_dir + '/database_copy.xlsx'
            idx_col = 'ID'

            Type = pd.read_excel(db_path, sheet_name = 'Lod1_Types', index_col = idx_col, engine = 'openpyxl')

            # Name
            if dlg.textEditName.isNull():
                QMessageBox.warning(None, 'Error in Name','Enter a name for new type')
            elif dlg.textEditName.value().startswith('test'):
                QMessageBox.warning(None, 'Error in Name','Please, don´t use test as type name..')
            elif dlg.textEditName.value().startswith('Test'):
                QMessageBox.warning(None, 'Error in Name','Please, don´t use test as type name..')
            elif dlg.textEditName.value() in Type['Type'].tolist():
                QMessageBox.warning(None, 'Error in Name','The suggested type name is already taken.')
    
            # Origin
            elif dlg.textEditOrig.isNull():
                QMessageBox.warning(None, 'Error in Origin','Enter a Origin for new type')

            # Final - When all is Checked 
            else:
                QMessageBox.information(None, 'Check Complete', 'Your type is compatible with the SUEWS-Database!\nPress Generate Type to add to your local Database')
                dlg.pushButtonGen.setEnabled(True)

        def generate_type():

            Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()
            table_dict,table_dict_ID,table_dict_pd,dict_str_var, dict_gen_type = self.get_dicts(veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            dict_reclass = {
                'ID' : str('Type' + str(int(round(time.time())))),
                'Origin' : str(dlg.textEditOrig.value()),
                'Type' : str(dlg.textEditName.value()),
                'Description': dlg.textEditDesc.value(),
                'Period' : dlg.textEditPeriod.value(),
                'Url' : '', 
                'Author' : 'SUEWS',
            }

            cbox_list = [dlg.comboBoxPavedType, dlg.comboBoxBuildingType, dlg.comboBoxGrassType, dlg.comboBoxDecType, dlg.comboBoxEvrType,dlg.comboBoxBsoilType, dlg.comboBoxWaterType]
            cbox_table_list = [nonveg, nonveg, veg, veg, veg, nonveg, water]
            dict_label = ['Paved', 'Building', 'Grass', 'Decidous Tree', 'Evergreen Tree', 'Bare Soil', 'Water']

            for cbox, surf_table, label in zip(cbox_list, cbox_table_list, dict_label):
                merge_list = []
                for i in range(len(surf_table)):
                    merge_list.append(str(surf_table['Type'].iloc[i]) + ', ' + str(surf_table['Origin'].iloc[i]))

                surf_table['TypeYear'] = merge_list
                
                dict_reclass[label] = surf_table[surf_table['TypeYear'] == cbox.currentText()].index.item()
    
            Type = Type.append(pd.DataFrame.from_dict([dict_reclass]).set_index('ID'))
    
            self.write_to_db(Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

        # Update rest of ComboBoxes
        def type_changed(): 
            try:          
                urb_type = dlg.comboBoxTableSelect.currentText()
                TypeID =Type[Type['type_origin'] == urb_type].index.item()
        
                # for i in [dlg.comboBoxEvrType, dlg.comboBoxDecType, dlg.comboBoxGrassType,
                # dlg.comboBoxRoofMtr, dlg.comboBoxWaterType, dlg.QgsFieldComboBox dlg.comboBoxBsoilType]:
                #     i.clear()
        
                def add_to_combobox(cbox, sheet, surface):
                    cbox.clear()
                    item_list = sheet['Type'][sheet['Surface'] == surface].tolist()
                    origin = sheet['Origin'][sheet['Surface'] == surface].tolist()
                    
                    merge_list = []
                    for i, j in zip(item_list, origin):
                        # Join type and origin to present for user
                        merge_list.append((i + ', ' + j))

                    cbox.addItems(merge_list)
                    # Set index according to selected base type
                    try:
                        indexer = sheet.loc[Type.loc[TypeID, surface],'Type']
                        print(indexer)
                        cbox.setCurrentIndex(item_list.index(indexer))
                    except:
                        pass
          
                add_to_combobox(dlg.comboBoxEvrType, veg, 'Evergreen Tree')
                add_to_combobox(dlg.comboBoxDecType, veg, 'Decidous Tree')
                add_to_combobox(dlg.comboBoxGrassType,veg, 'Grass')
                add_to_combobox(dlg.comboBoxBuildingType, nonveg,  'Building')
                add_to_combobox(dlg.comboBoxPavedType, nonveg, 'Paved')
                add_to_combobox(dlg.comboBoxBsoilType, nonveg, 'Bare Soil')
                add_to_combobox(dlg.comboBoxWaterType, water, 'Water')
            
            except:
                pass
           
        dlg.comboBoxTableSelect.currentIndexChanged.connect(type_changed)
        
        def surface_info_changed(self):
            # Clear and enable ComboBox
            dlg.comboBoxElementInfo.clear()
            dlg.comboBoxElementInfo.setEnabled(True)
            # Read what surface user has chosen
            surface = dlg.comboBoxSurface.currentText()

            # Select correct tab fom DB (Veg, NonVeg or Water)
            if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                item_list = nonveg['Type'][nonveg['Surface'] == surface].tolist()
                origin = nonveg['Origin'][nonveg['Surface'] == surface].tolist()
                clr = nonveg['Color'][nonveg['Surface'] == surface].tolist()

                app_list = []
                for item, origin, clr in zip(item_list, origin, clr):
                    # Join type and origin to present for user
                    app_list.append((clr + ' ' + item + ', ' + origin))

            elif surface == 'Water':
                item_list = nonveg['Type'][nonveg['Surface'] == surface].tolist()
                origin = nonveg['Origin'][nonveg['Surface'] == surface].tolist()

                app_list = []
                for i, j in zip(item_list, origin):
                    # Join type and origin to present for user
                    app_list.append((i + ', ' + j))
            else: 
                item_list = veg['Type'][veg['Surface'] == surface].tolist()
                origin = veg['Origin'][veg['Surface'] == surface].tolist()

                app_list = []
                for i, j in zip(item_list, origin):
                    # Join type and origin to present for user
                    app_list.append((i + ', ' + j))

            dlg.comboBoxElementInfo.addItems(app_list)
        
        
        def surface_info_changed(self):
            # Clear and enable ComboBox
            dlg.comboBoxElementInfo.clear()
            dlg.comboBoxElementInfo.setEnabled(True)
            # Read what surface user has chosen
            surface = dlg.comboBoxSurface.currentText()

            # Select correct tab fom DB (Veg, NonVeg or Water)
            if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                item_list = nonveg['Type'][nonveg['Surface'] == surface].tolist()
                origin = nonveg['Origin'][nonveg['Surface'] == surface].tolist()
                clr = nonveg['Color'][nonveg['Surface'] == surface].tolist()

                app_list = []
                for item, origin, clr in zip(item_list, origin, clr):
                    # Join type and origin to present for user
                    app_list.append((clr + ' ' + item + ', ' + origin))

            elif surface == 'Water':
                item_list = nonveg['Type'][nonveg['Surface'] == surface].tolist()
                origin = nonveg['Origin'][nonveg['Surface'] == surface].tolist()

                app_list = []
                for i, j in zip(item_list, origin):
                    # Join type and origin to present for user
                    app_list.append((i + ', ' + j))

            else: 
                item_list = veg['Type'][veg['Surface'] == surface].tolist()
                origin = veg['Origin'][veg['Surface'] == surface].tolist()

                app_list = []
                for i, j in zip(item_list, origin):
                    # Join type and origin to present for user
                    app_list.append((i + ', ' + j))

            dlg.comboBoxElementInfo.addItems(app_list)
        
        dlg.comboBoxSurface.currentIndexChanged.connect(surface_info_changed)

        dlg.pushButtonCheck.clicked.connect(check_type)
        dlg.pushButtonGen.clicked.connect(generate_type)
        dlg.pushButtonGen.clicked.connect(self.resetTypeEditor)
        #        dlg.pushButtonUpdate.clicked.connect(self.resetTypeEditor)

    def resetTypeEditor(self):
        self.setup_tabs()
        self.dlg.tabWidget.setCurrentIndex(1)
        QMessageBox.information(None, 'Sucessful','Database Updated')

    #################################################################################################
    #                                                                                               #
    #                                  Urban Element Creator                                        #
    #                                                                                               #
    #################################################################################################

    def setup_urban_elements_creator(self, dlg):

        # Read database and get dataframes
        Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()

        table_dict,table_dict_ID,table_dict_pd,dict_str_var,dict_gen_type = self.get_dicts(veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)
     
        rev_table_dict = dict((v, k) for k, v in table_dict_ID.items())
        
        dlg.comboBoxSurface.setCurrentIndex(-1)
        
        dlg.textBrowserColor.setHidden(True)
        dlg.textEditColor.setHidden(True)

        def changed_surface():
            
            for i in range(0,13):
                Oc = eval('dlg.textBrowser_' + str(i))
                Oc.clear()
                Oc.setDisabled(True)
                Nc = eval('dlg.comboBox_' + str(i))
                Nc.setDisabled(True)
                Nc.clear()
                Tb = eval('dlg.textBrowserTab' + str(i))
                Tb.setDisabled(True)
                Tb.clear()
                Cb = eval('dlg.checkBox' + str(i))
                Cb.setChecked(False)

            # Clear and enable ComboBox
            dlg.comboBoxBaseElement.clear()
            dlg.comboBoxBaseElement.setEnabled(True)
            
            # Read what surface user has chosen
            surface = dlg.comboBoxSurface.currentText()


            # Select correct tab fom DB (Veg, NonVeg or Water)
            if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                item_list = nonveg['Type'][nonveg['Surface'] == surface].tolist()
                origin = nonveg['Origin'][nonveg['Surface'] == surface].tolist()
                clr = nonveg['Color'][nonveg['Surface'] == surface].tolist()

                app_list = []
                for item, origin, clr in zip(item_list, origin, clr):
                    # Join type and origin to present for user
                    app_list.append((clr + ' ' + item + ', ' + origin))

                dlg.textBrowserColor.setVisible(True)
                dlg.textEditColor.setVisible(True)
            
            elif surface == 'Water':
                item_list = water['Type'][water['Surface'] == surface].tolist()
                origin = water['Origin'][water['Surface'] == surface].tolist()
                app_list = []
                for i, j in zip(item_list, origin):
                    # Join type and origin to present for user
                    app_list.append((i + ', ' + j))

                dlg.textBrowserColor.setHidden(True)
                dlg.textEditColor.setHidden(True)

            else: 
                item_list = veg['Type'][veg['Surface'] == surface].tolist()
                origin = veg['Origin'][veg['Surface'] == surface].tolist()
                app_list = []
                for i, j in zip(item_list, origin):
                    # Join type and origin to present for user
                    app_list.append((i + ', ' + j))

                dlg.textBrowserColor.setHidden(True)
                dlg.textEditColor.setHidden(True)

            dlg.comboBoxBaseElement.addItems(app_list)
            dlg.comboBoxBaseElement.setCurrentIndex(-1)

            table = table_dict_pd[str(surface)]
            col_list = list(table)

            remove_cols = ['ID', 'Surface', 'Color', 'Origin', 'Type']

            if surface != 'Decidous Tree':
                remove_cols.append('Por') # Exception for just Decidous tree in Veg

            for col in remove_cols:
                try:
                    col_list.remove(col)
                except:
                    pass
            # Clear ComboBoxes 

            for i in range(len(col_list)): 
                          
                Oc = eval('dlg.textBrowser_' + str(i))
                Oc.setEnabled(True)
                # Tb = Text Browser with table
                Tb = eval('dlg.textBrowserTab' + str(i))
                Tb.setEnabled(True)
                # Nc = Combobox with selectable table rows
                Nc = eval('dlg.comboBox_' + str(i))
                Nc.setEnabled(True)
                
                # Assign correct tab
                try:
                    table_name_str = rev_table_dict[col_list[i]]
                except:
                    pass
                
                # Fill in name of table
                Oc.setText(table_name_str)

                table = table_dict_pd[table_name_str]
                table_surf = table[table['Surface'] == surface]

                ref_show = ref['authoryear'].to_dict()
                table_surf['Reference'] = '' 
                for i in range(len(table_surf)):
                    table_surf['Reference'].iloc[i] = ref_show[table_surf['Ref'].iloc[i]] 
                
                table_sel = table_surf.drop(columns =['Surface','General Type', 'Ref']).reset_index()
                
                try :
                    table_surf.drop(columns =['descOrigin'])
                except:
                    pass

                table_sel = table_sel.drop(columns = ['ID'])
                Tb.setText(str(table_sel.to_html(index=True))) 

                Nc_fill_list = []
                idx = 0
                for desc, orig, idx in zip(table_surf['Description'].tolist() ,table_surf['Origin'].tolist(), list(range(len(table_surf['Origin'].tolist())))):
                    Nc_fill_list.append((str(idx) + ': ' + desc + ', ' + orig))
                
                Nc.addItems(Nc_fill_list)
        
        dlg.comboBoxSurface.currentIndexChanged.connect(changed_surface)

        def base_element_changed():
            surface = dlg.comboBoxSurface.currentText()
            surf_table = table_dict_pd[surface]
            merge_list = []
            if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                for i in range(len(table_dict_pd[surface])):
                    merge_list.append(
                        str(surf_table['Color'].iloc[i]) + 
                        ' ' + 
                        str(surf_table['Type'].iloc[i]) + 
                        ', ' +
                         str(surf_table['Origin'].iloc[i]))
                lod_2 = nonveg
            elif surface == 'Water':
                for i in range(len(table_dict_pd[surface])):
                    merge_list.append(
                        str(surf_table['Type'].iloc[i]) +
                         ', ' +
                          str(surf_table['Origin'].iloc[i]))
                lod_2 = water
                
            else:
                for i in range(len(table_dict_pd[surface])):
                    merge_list.append(
                        str(surf_table['Type'].iloc[i]) +
                         ', ' +
                          str(surf_table['Origin'].iloc[i]))
                lod_2 = veg
                
            surf_table['TypeOrigin'] = merge_list
            item_list = surf_table[surf_table['Surface'] == surface]
            base_element = dlg.comboBoxBaseElement.currentText()
            print('837')
            try:
                idx = item_list[item_list['TypeOrigin'] == base_element].index.item()
                # base_element_ID = surf_table[surf_table['TypeOrigin'] == base_element].index.item()
                #     # Set index according to selected base type
                # indexer = surf_table.loc[Type.loc[base_element_ID, surface],'Type']
                col_list = list(surf_table)
                remove_cols = ['ID', 'Surface', 'Color', 'Origin', 'Type']
                print('845')
                if surface != 'Decidous Tree':
                    remove_cols.append('Por') # Exception for just Decidous tree in Veg

                for col in remove_cols:
                    try:
                        col_list.remove(col)
                    except:
                        pass

                for i in range(len(col_list)): 
                    Nc = eval('dlg.comboBox_' + str(i))
                    Nc.setEnabled(True)
                    
                    # Assign correct tab
                    table_name_str = rev_table_dict[col_list[i]]
                    
                    table = table_dict_pd[table_name_str]
                    table_surf = table[table['Surface'] == surface]

                    origin = table['Origin'][table['Surface'] == surface].tolist()
                    merge_list = []
                    if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                        for i in range(len(table_dict_pd[surface])):
                            merge_list.append(
                                str(table_surf['Color'].iloc[i]) + 
                                ' ' + 
                                str(table_surf['Type'].iloc[i]) + 
                                ', ' +
                                str(table_surf['Origin'].iloc[i]))
                        else:
                            for i in range(len(table_dict_pd[surface])):
                                merge_list.append(
                                    str(table_surf['Type'].iloc[i]) +
                                    ', ' +
                                    str(table_surf['Origin'].iloc[i]))
                            lod_2 = veg
                    # # Set index according to selected base type

                    a  = lod_2.loc[idx, table_dict_ID[table_name_str]]
                    indexer = table_surf.loc[a, 'Description']
                    #indexer = table.loc[lod_2.loc[idx, table_dict_ID[table_name_str]],'Descripiton']
                    print('877')
                    Nc.setCurrentIndex(item_list.index(str(indexer)))


                print('')

            except:
                pass
            print('')
            

        def print_table(idx):
            surface = dlg.comboBoxSurface.currentText()
            
            if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                table_name = nonveg
            elif surface == 'Water':
                table_name = water # CHANGE TO WATER
            else:
                table_name = veg

            table = table_name[table_name['Surface'] == surface]

            table_indexer = eval('dlg.textBrowserTab' + str(idx)) 
            table_indexer.clear()
            vars()['dlg.textBrowserTab' + str(idx)] = table_indexer
            
            table_id = eval('dlg.comboBox_' + str(idx))
            vars()['dlg.comboBox_' + str(idx)] = table_id
            table_id = table_id.currentText()

        def check_element():
            QMessageBox.information(None, 'Sucessful','Your Element is compatible. \n Press Add Element to add to your Local Database')
            dlg.pushButtonGen.setEnabled(True)

        def generate_element():
            # self.write_to_db(Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)
            db_path = self.plugin_dir + '/database_copy.xlsx'  

            Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()
            table_dict,table_dict_ID,table_dict_pd,dict_str_var,dict_gen_type = self.get_dicts(veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            # Nonveg or veg or water?
            surface = dlg.comboBoxSurface.currentText()

            table = table_dict_pd[surface]

            col_list = list(table)
            remove_cols = ['ID', 'Surface', 'Color', 'Origin', 'Type']
            for col in remove_cols:
                try:
                    col_list.remove(col)
                except:
                    pass

            dict_reclass = {
                'ID' : str(table_dict_ID[surface] + str(int(round(time.time())))),
                'Surface' : surface,
                'Origin' : str(dlg.textEditLoc.toPlainText()),
                'Type' : str(dlg.textEditType.toPlainText()),
                #'Author' : str(dlg.textEditAutor.toPlainText())
            }

            for i in range(len(col_list)):
                Oc = eval('dlg.textBrowser_' + str(i))
                oldField = Oc.toPlainText()
                Nc = eval('dlg.comboBox_' + str(i))
                sel_att = Nc.currentText() 

                table = table_dict_pd[oldField]

                descOrigin_list = []
                for i in range(len(table)):
                    descOrigin_list.append(str(table['Description'].iloc[i]) + ', ' + str(table['Origin'].iloc[i]))

                idx_table= table.copy()
                idx_table['descOrigin'] = descOrigin_list
                sel_att = sel_att.split(':')[1] # Remove number added for interpretation in GUI
                newField = idx_table[idx_table['descOrigin'] == sel_att].index.item()
                
                dict_reclass[table_dict_ID[oldField]] = newField
            
            df_new_edit = pd.DataFrame(dict_reclass, index = [0]).set_index('ID')

            # Add new line to correct tab veg, nonveg or water
            if surface == 'Paved' or surface == 'Building' or surface == 'Bare Soil':
                df_new_edit['Color'] = dlg.textEditColor.toPlainText()
                nonveg = nonveg.append(df_new_edit)
            elif surface == 'Water':
                water = water.append(df_new_edit)
            else:
                veg = veg.append(df_new_edit)
            
            # Write to db
            self.write_to_db(Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            QMessageBox.information(None, 'Sucessful','Element Added')

        dlg.pushButtonCheck.clicked.connect(check_element)
        dlg.pushButtonGen.clicked.connect(generate_element)
        dlg.comboBoxBaseElement.currentIndexChanged.connect(base_element_changed)
        dlg.pushButtonGen.clicked.connect(self.reset_surface_editor)

    def reset_surface_editor(self):
        self.setup_tabs()
        self.dlg.tabWidget.setCurrentIndex(2)




    #################################################################################################
    #                                                                                               #
    #                                  Urban Table Editor                                        #
    #                                                                                               #
    #################################################################################################

    # TODO CHANGE Numbers in combo and scrollboxes to 0 and drop description and origin 

    def setup_urban_db_type_editor(self, dlg):
        

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        # if self.first_start == True:
        #     self.first_start = False
        #     self.dlg = urban_type_db_editorDialog()
        
        for i in range(0,11):
            Oc = eval('dlg.textBrowser_' + str(i))
            Oc.clear()
            Oc.setDisabled(True)

            Nc = eval('dlg.textEdit_Edit_' + str(i))
            Nc.clear()
            Nc.setDisabled(True)
        
        # dlg.comboBoxTableSelect.clear()
        # dlg.comboBoxRef.clear()
        
        Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()
        table_dict,table_dict_ID,table_dict_pd,dict_str_var,dict_gen_type = self.get_dicts(veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

        rev_table_dict = dict((v, k) for k, v in table_dict.items())
        # Remove Conductance in some way

        dlg.comboBoxTableSelect.addItems(sorted((list(rev_table_dict.values()))))
        dlg.comboBoxTableSelect.setCurrentIndex(-1)
        
        ref_list = []
        for i in range(len(ref)):
            ref_list.append(str(ref['Author'].iloc[i]) + ' (' + str(ref['Publication Year'].iloc[i]) + ')')
        ref['authoryear'] = ref_list
        dlg.comboBoxRef.addItems(sorted(ref_list)) 
        dlg.comboBoxRef.setCurrentIndex(-1)
        
        def table_changed():
            table_name = dlg.comboBoxTableSelect.currentText()

            # Clear ComboBoxes
            dlg.textBrowserDf.clear()
            for i in range(0,11):
                # Oc == Old Class
                Oc = eval('dlg.textBrowser_' + str(i))
                Oc.clear()
                Oc.setDisabled(True)
   
                Nc = eval('dlg.textEdit_Edit_' + str(i))
                Nc.clear()
                Nc.setDisabled(True)

            try:
                table = table_dict_pd[str(table_name)]
                col_list = list(table)
                
                columns_to_remove = ['General Type', 'Surface', 'Description','Origin','Ref', 'Reference']

                for remove in columns_to_remove:
                    try:
                        col_list.remove(remove)
                    except:
                        pass

                len_list = len(col_list)
                for idx in range(len_list):
                    Oc = eval('dlg.textBrowser_' + str(idx))
                    Oc.setEnabled(True)
                    Oc.setText(str(col_list[idx]))

                    Nc = eval('dlg.textEdit_Edit_' + str(idx))
                    Nc.setEnabled(True)

                
                if table_name == 'Leaf Area Index' or table_name == 'Leaf Growth Power' or table_name == 'Max Vegetation Conductance' or table_name == 'Vegetation Growth' or table_name == 'Biogen CO2':
                    dlg.comboBoxSurface.clear()
                    dlg.comboBoxSurface.addItems(['Evergreen Tree', 'Decidous Tree','Grass'])
                elif table_name == 'Porosity':
                    dlg.comboBoxSurface.clear()
                    dlg.comboBoxSurface.addItems(['Decidous Tree'])
                else:
                    dlg.comboBoxSurface.clear()
                    dlg.comboBoxSurface.addItems(['Paved', 'Building','Evergreen Tree', 'Decidous Tree', 'Grass', 'Bare Soil', 'Water'])
                dlg.comboBoxSurface.setEnabled(True)
                dlg.comboBoxSurface.setCurrentIndex(-1)

                #self.dlg.textBrowserNewID.setText(str(' '.join(re.findall('[a-zA-Z]+', table.index[1])))+ str(len(table)+1))
                            
                ref_show = ref['authoryear'].to_dict()
                table['Reference'] = '' 
                for i in range(len(table)):
                    table['Reference'].iloc[i] = ref_show[table['Ref'].iloc[i]] 
                
                text_table = table.drop(columns =['Surface','General Type', 'Ref']).reset_index()
    
                dlg.textBrowserDf.setText(str(text_table.drop(columns='ID').to_html()))        
                dlg.comboBoxSurface.setCurrentIndex(-1)
            except:
                pass

        dlg.comboBoxTableSelect.currentIndexChanged.connect(table_changed) 
        
        def surface_changed():
            table_name = dlg.comboBoxTableSelect.currentText()
            surface = dlg.comboBoxSurface.currentText()
            table = table_dict_pd[str(table_name)]
            table_surf = table[table['Surface'] == surface]

            ref_show = ref['authoryear'].to_dict()
            table_surf['Reference'] = '' 
            for i in range(len(table_surf)):
                table_surf['Reference'].iloc[i] = ref_show[table_surf['Ref'].iloc[i]] 
            
            text_table = table_surf.drop(columns =['Surface','General Type', 'Ref']).reset_index()

            dlg.textBrowserDf.setText(str(text_table.drop(columns='ID').to_html()))   

        dlg.comboBoxSurface.currentIndexChanged.connect(surface_changed)

        def ref_changed():
            dlg.textBrowserRef.clear()

            try:
                ID = ref[ref['authoryear'] ==  dlg.comboBoxRef.currentText()].index.item()
                dlg.textBrowserRef.setText(
                    '<b>Author: ' +'</b>' + str(ref.loc[ID, 'Author']) + '<br><br><b>' +
                    'Year: ' + '</b> '+ str(ref.loc[ID, 'Publication Year']) + '<br><br><b>' +
                    'Title: ' + '</b> ' +  str(ref.loc[ID, 'Title']) + '<br><br><b>' +
                    'Journal: ' + '</b>' + str(ref.loc[ID, 'Journal']) + '<br><br><b>' 
                )
            except:
                pass
    
        dlg.comboBoxRef.currentIndexChanged.connect(ref_changed)

        def check_reference():
            dlg.pushButtonAddRef.setEnabled(True)
            QMessageBox.information(None, 'Sucessful','Your reference is compatible. \n Press Add Refernce to add to your Local Database')

        def add_reference():
            Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()

            dict_reclass = {
                'ID' : 'Ref' + str(int(round(time.time()))),
                'Author' : dlg.textEditRefAuthor.value(),
                'Title' : dlg.textEditRefTitle.value(),
                'Publication Year' : dlg.textEditRefYear.value(),
                'Journal' : dlg.textEditRefJournal.value(),
            }

            new_edit_ref = pd.DataFrame(dict_reclass, index=[0]).set_index('ID')

            ref = ref.append(new_edit_ref)
            
            self.write_to_db(Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            QMessageBox.information(None, 'Sucessful','Reference Added')


        def add_table():

            Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()

            table_dict,table_dict_ID,table_dict_pd,dict_str_var,dict_gen_type= self.get_dicts(veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)


            table = table_dict_pd[str(dlg.comboBoxTableSelect.currentText())]

            col_list = list(table)
            
            columns_to_remove = ['General Type', 'Surface', 'Description','Origin','Ref','Reference']

            for remove in columns_to_remove:
                try:
                    col_list.remove(remove)
                except:
                    pass

            len_list = len(col_list)

            dict_reclass = {
                'ID' : str(table_dict_ID[str(dlg.comboBoxTableSelect.currentText())] + str(int(round(time.time())))),
                'General Type' : dict_gen_type[dlg.comboBoxSurface.currentText()],
                'Surface' : dlg.comboBoxSurface.currentText(), 
                'Description' : dlg.textEditDesc.value(),
                'Origin' : dlg.textEditOrig.value()
            }
        
            for idx in range(len_list):
                # Left side
                Oc = eval('dlg.textBrowser_' + str(idx))
                oldField = Oc.toPlainText()
                vars()['dlg.textBrowser_' + str(idx)] = Oc
                # Right Side
                Nc = eval('dlg.textEdit_Edit_' + str(idx))
                newField = float(Nc.value())
                vars()['dlg.textEdit_Edit_' + str(idx)] = Nc
                dict_reclass[oldField] =  [newField]

            
            dict_reclass['Ref'] = ref[ref['authoryear'] ==  dlg.comboBoxRef.currentText()].index.item() 
            
            df_new_edit = pd.DataFrame(dict_reclass).set_index('ID')

            # IF Party to write to correct sheet in .xlsx
            
            var = dlg.comboBoxTableSelect.currentText()

            if var == 'Emissivity':
                em = em.append(df_new_edit)
            if var == 'Albedo':
                alb = alb.append(df_new_edit)
            elif var == 'OHM':
                OHM = OHM.append(df_new_edit)
            elif var == 'Leaf Area Index':
                LAI = LAI.append(df_new_edit)
            elif var == 'Conductance':
                cnd = cnd.append(df_new_edit)
            elif var == 'Leaf Growth Power':
                LGP = LGP.append(df_new_edit)
            elif var == 'Drainage':
                dr = dr.append(df_new_edit)
            elif var == 'Vegetation Growth':
                VG = VG.append(df_new_edit)
            elif var == 'ANOHM':
                ANOHM = ANOHM.append(df_new_edit)
            elif var == 'Biogen CO2':
                BIOCO2 = BIOCO2.append(df_new_edit)
            elif var == 'Max Vegetation Conductance':
                MVCND = MVCND.append(df_new_edit)
            elif var == 'Porosity':
                por = por.append(df_new_edit)
            else:
                print('Error!')
            
            # Write to db
            self.write_to_db(Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            QMessageBox.information(None, 'Sucessful','Edit Added')
    
        def checker():

            def special_match(strg, search=re.compile(r'[^0-9.]').search):
                return not bool(search(strg))

            var = dlg.comboBoxTableSelect.currentText()
            try:
                if len(dlg.comboBoxSurface.currentText()) <1: 
                    QMessageBox.warning(None, 'Surface Missing','Please select a surface')
                elif len(dlg.textEditDesc.value()) <1: 
                    QMessageBox.warning(None, 'Description Missing','Please fill in the Description Box')
                elif len(dlg.textEditOrig.value()) <1: 
                    QMessageBox.warning(None, 'Origin Missing','Please fill in the Origin Box')
                elif len(dlg.comboBoxRef.currentText()) <1:
                    QMessageBox.warning(None, 'Reference Missing','Please select a reference')
            except:
                pass 
            
            table = table_dict_pd[str(dlg.comboBoxTableSelect.currentText())]

            col_list = list(table)
            
            columns_to_remove = ['General Type', 'Surface', 'Description','Origin','Ref','Reference']

            for remove in columns_to_remove:
                try:
                    col_list.remove(remove)
                except:
                    pass

            dict_reclass = {
                # 'ID' : str(table_dict_ID[str(dlg.comboBoxTableSelect.currentText())] + str(int(round(time.time())))),
                'General Type' : dict_gen_type[dlg.comboBoxSurface.currentText()],
                'Surface' : dlg.comboBoxSurface.currentText(), 
                # 'Description' : dlg.textEditDesc.value(),
                # 'Origin' : dlg.textEditOrig.value()
            }

            len_list = len(col_list)
            col_list =['General Type', 'Surface']

            for idx in range(len_list):
                # Left side
                Oc = eval('dlg.textBrowser_' + str(idx))
                oldField = Oc.toPlainText()
                vars()['dlg.textBrowser_' + str(idx)] = Oc
                # Right Side
                Nc = eval('dlg.textEdit_Edit_' + str(idx))

                if(len(Nc.value())) <1:
                    QMessageBox.warning(None, oldField + ' Missing','Enter value for ' + oldField)
                    break

                if Oc.toPlainText() != 'Season':
                    if  special_match(Nc.value()) == False:
                        QMessageBox.warning(None, oldField + ' Error','Invalid characters in ' + oldField + '\nOnly 0-9 and . are allowed')
                        break

                try:
                    newField = float(Nc.value())
                    vars()['dlg.textEdit_Edit_' + str(idx)] = Nc
                    dict_reclass[oldField] =  [newField]
                    col_list.append(Oc.toPlainText())

                    dict_reclass['Ref'] = ref[ref['authoryear'] ==  dlg.comboBoxRef.currentText()].index.item() 
                    df_new_edit = pd.DataFrame(dict_reclass)
                    col_list.append('Ref')

                    row = len(table.index)
                    col = len(table[col_list].columns)

                    try:
                        if var == 'Albedo':
                            if float(dlg.textEdit_Edit_0.value()) < 0 or float(dlg.textEdit_Edit_0.value()) > 1:
                                QMessageBox.warning(None, 'Albedo Min error','Alb_min must be between 0-1')
                                break
                            elif float(dlg.textEdit_Edit_1.value()) < 0 or float(dlg.textEdit_Edit_1.value()) > 1:
                                QMessageBox.warning(None, 'Albedo Max error','Alb_max must be between 0-1')
                                break
                            elif float(dlg.textEdit_Edit_0.value()) > float(dlg.textEdit_Edit_1.value()):
                                QMessageBox.warning(None, 'Value error', dlg.textBrowser_0.toPlainText() + ' must be smaller or equal to ' + dlg.textBrowser_1.toPlainText())
                                break

                        elif var == 'Leaf Area Index':
                            if float(dlg.textEdit_Edit_0.value()) != 0 or float(dlg.textEdit_Edit_0.value()) != 1:
                                QMessageBox.warning(None, 'LAI Equation error','LAIeq choices are 0 or 1')
                                break
                            elif float(dlg.textEdit_Edit_1.value()) < 0 or float(dlg.textEdit_Edit_1.value()) > 1:
                                QMessageBox.warning(None, 'LAImin error','LAImin must be between 0-1')
                                break
                            elif float(dlg.textEdit_Edit_2.value()) < 0 or float(dlg.textEdit_Edit_2.value()) > 1:
                                QMessageBox.warning(None, 'LAImax error','LAImax must be between 0-1')
                                break
                            elif float(dlg.textEdit_Edit_1.value()) > float(dlg.textEdit_Edit_2.value()):
                                QMessageBox.warning(None, 'Value error', dlg.textBrowser_1.toPlainText() + ' must be smaller or equal to ' + dlg.textBrowser_2.toPlainText())
                                break

                        elif var == 'Porosity':
                            if float(dlg.textEdit_Edit_0.value()) > float(dlg.textEdit_Edit_1.value()):
                                QMessageBox.warning(None, 'Value error', dlg.textBrowser_0.toPlainText() + ' must be smaller or equal to ' + dlg.textBrowser_1.toPlainText())
                                break

                        elif var == 'Emissivity':
                            if float(dlg.textEdit_Edit_0.value()) < 0 or float(dlg.textEdit_Edit_0.value()) > 1:
                                QMessageBox.warning(None, 'Emissivity error','Emissivity must be between 0-1')
                                break

                        for i in range(row):
                            checker = 0
                            for j in range(col):
                                if table[col_list].iloc[i].tolist()[j] == df_new_edit.iloc[0].tolist()[j]:
                                    checker = checker+1
                            if checker == col:
                                QMessageBox.information(None, 'Information',
                                    'Another entry in the database with same Values and Referece is found in the Database' +
                                    '\n\n[ ' +  str(table.loc[table.index[i], 'Description']) + ', ' + str(table.loc[table.index[i], 'Origin']) + 
                                    ', ' + str(table.loc[table.index[i], 'Reference'] + ' ]' +
                                    '\n\nYou are able to add the entry if you  think this is different from what already exist in the database!'))
                    
                        QMessageBox.information(None, 'Succesful', 'Your edit is compatible! Press Add Table to add it to your local database')
                        dlg.pushButtonGen.setEnabled(True)
                    except:
                        pass
                except:
                    pass

            # elif var == 'OHM'
            #     OHM = OHM.append(df_new_edit)
            # elif var == 'Leaf Area Index':
            #     LAI = LAI.append(df_new_edit)
            # elif var == 'Conductance':
            #     cnd = cnd.append(df_new_edit)
            # elif var == 'Leaf Growth Power':
            #     LGP = LGP.append(df_new_edit)
            # elif var == 'Drainage':
            #     dr = dr.append(df_new_edit)

        dlg.pushButtonCheck.clicked.connect(checker)
        dlg.pushButtonGen.clicked.connect(add_table)
        dlg.pushButtonGen.clicked.connect(self.reset_DB_editor)
        dlg.pushButtonCheckRef.clicked.connect(check_reference)
        dlg.pushButtonAddRef.clicked.connect(add_reference)
        dlg.pushButtonAddRef.clicked.connect(self.reset_DB_editor)

    #################################################################################################
    #                                                                                               #
    #                                  ESTM_creator                                                 #
    #                                                                                               #
    #################################################################################################

    # TODO CHANGE Numbers in combo and scrollboxes to 0 and drop description and origin 

    def setup_ESTM_creator(self, dlg):

        Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por = self.read_db()
        table_dict,table_dict_ID,table_dict_pd,dict_str_var,dict_gen_type= self.get_dicts(veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)
        
        for i in range(0,51):
            Tb = eval('dlg.textBrowser_' + str(i))
            Le = eval('dlg.ESTMlineEdit' + str(i))
            Le.clear()
            Le.setText(str(-999))
        
        def show_references():
            
            db_path = self.plugin_dir + '/database_copy.xlsx'
            ref = pd.read_excel(db_path, sheet_name= 'References', index_col=  'ID', engine= 'openpyxl')
            ref_list = []
            for i in range(len(ref)):
                ref_list.append(str(ref['Author'].iloc[i]) + ' (' + str(ref['Publication Year'].iloc[i]) + ')')
            ref['authoryear'] = ref_list
            dlg.comboBoxRef.addItems(sorted(ref_list)) 
            dlg.comboBoxRef.setCurrentIndex(-1)
        
        show_references()
        
        def ref_changed():
            dlg.textBrowserRef.clear()

            try:
                ID = ref[ref['authoryear'] ==  dlg.comboBoxRef.currentText()].index.item()
                dlg.textBrowserRef.setText(
                    '<b>Author: ' +'</b>' + str(ref.loc[ID, 'Author']) + '<br><br><b>' +
                    'Year: ' + '</b> '+ str(ref.loc[ID, 'Publication Year']) + '<br><br><b>' +
                    'Title: ' + '</b> ' +  str(ref.loc[ID, 'Title']) + '<br><br><b>' +
                    'Journal: ' + '</b>' + str(ref.loc[ID, 'Journal']) + '<br><br><b>'
                )
            except:
                pass
    
        dlg.comboBoxRef.currentIndexChanged.connect(ref_changed) 

        def add_reference():

            dict_reclass = {
                'ID' : 'Ref' + str(int(round(time.time()))),
                'Author' : dlg.textEditRefAuthor.value(),
                'Title' : dlg.textEditRefTitle.value(),
                'Publication Year' : dlg.textEditRefYear.value(),
                'Journal' : dlg.textEditRefJournal.value(),
            }

            new_edit_ref = pd.DataFrame(dict_reclass, index=[0]).set_index('ID')

            db_path = self.plugin_dir + '/database_copy.xlsx'
            ref = pd.read_excel(db_path, sheet_name= 'References', index_col=  'ID', engine= 'openpyxl')

            ref = ref.append(new_edit_ref)
            
            self.write_to_db(Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por)

            QMessageBox.information(None, 'Sucessful','Reference Added')

        dlg.pushButtonAddRef.clicked.connect(add_reference)
        dlg.pushButtonAddRef.clicked.connect(show_references) # Update only ref? and things related to that!
    


    #######################################################################################################################################
    #######################################################################################################################################
    #######################################################################################################################################
    #######################################################################################################################################

    def read_db(self):
        db_path = self.plugin_dir + '/database_copy.xlsx'  
        idx_col = 'ID'
        # Lod 1
        Type = pd.read_excel(db_path, sheet_name = 'Lod1_Types', index_col=  idx_col, engine = 'openpyxl')
        # Lod 2
        veg = pd.read_excel(db_path, sheet_name = 'Lod2_Veg', index_col = idx_col, engine = 'openpyxl')
        veg.name = 'Lod2_Veg'
        nonveg = pd.read_excel(db_path, sheet_name = 'Lod2_NonVeg', index_col = idx_col, engine = 'openpyxl')
        nonveg.name = 'Lod2_NonVeg'
        water = pd.read_excel(db_path, sheet_name = 'Lod2_Water', index_col = idx_col, engine = 'openpyxl')
        water.name = 'Lod2_Water'
        # Ref
        ref = pd.read_excel(db_path, sheet_name = 'References', index_col = idx_col, engine = 'openpyxl')
        # Lod 3
        alb =  pd.read_excel(db_path, sheet_name = 'Lod3_Albedo', index_col = idx_col, engine = 'openpyxl')
        alb.name = 'Lod3_Albedo'
        em =  pd.read_excel(db_path, sheet_name = 'Lod3_Emissivity', index_col = idx_col, engine = 'openpyxl')
        em.name = 'Lod3_Emissivity'
        OHM =  pd.read_excel(db_path, sheet_name = 'Lod3_OHM', index_col = idx_col, engine = 'openpyxl') # Away from Veg
        OHM.name = 'Lod3_OHM'
        LAI =  pd.read_excel(db_path, sheet_name = 'Lod3_LAI', index_col = idx_col, engine = 'openpyxl')
        LAI.name = 'Lod3_OHM'
        st = pd.read_excel(db_path, sheet_name = 'Lod3_Storage', index_col = idx_col, engine = 'openpyxl')
        st.name = 'Lod3_Storage'
        cnd = pd.read_excel(db_path, sheet_name = 'Lod3_Conductance', index_col = idx_col, engine = 'openpyxl') # Away from Veg
        cnd.name = 'Lod3_Conductance'
        LGP = pd.read_excel(db_path, sheet_name = 'Lod3_LGP', index_col = idx_col, engine = 'openpyxl')
        LGP.name = 'Lod3_LGP'
        dr = pd.read_excel(db_path, sheet_name = 'Lod3_Drainage', index_col = idx_col, engine = 'openpyxl')
        dr.name = 'Lod3_Drainage'
        VG = pd.read_excel(db_path, sheet_name = 'Lod3_VegetationGrowth', index_col = idx_col, engine = 'openpyxl')
        VG.name = 'Lod3_VegetationGrowth'
        ANOHM = pd.read_excel(db_path, sheet_name = 'Lod3_ANOHM', index_col = idx_col, engine = 'openpyxl')
        ANOHM.name = 'Lod3_ANOHM'
        BIOCO2 = pd.read_excel(db_path, sheet_name = 'Lod3_BiogenCO2',index_col = idx_col, engine = 'openpyxl')
        BIOCO2.name = 'Lod3_BiogenCO2'
        MVCND = pd.read_excel(db_path, sheet_name= 'Lod3_MaxVegetationConductance', index_col = idx_col, engine = 'openpyxl')
        MVCND.name = 'Lod3_MaxVegetationConductance'
        por = pd.read_excel(db_path, sheet_name = 'Lod3_Porosity', index_col = idx_col, engine = 'openpyxl')
        por.name = 'Lod3_Porosity'
        
        return Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por

    def write_to_db(self,Type, veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por):

            db_path = self.plugin_dir + '/database_copy.xlsx'  
            writer = pd.ExcelWriter(db_path)

            Type.to_excel(writer, sheet_name = 'Lod1_Types')
            veg.to_excel(writer, sheet_name = 'Lod2_Veg')
            nonveg.to_excel(writer, sheet_name = 'Lod2_NonVeg')
            water.to_excel(writer, sheet_name = 'Lod2_Water')
            ref.to_excel(writer, sheet_name = 'References')
            alb.to_excel(writer, sheet_name = 'Lod3_Albedo')
            em.to_excel(writer, sheet_name = 'Lod3_Emissivity')
            OHM.to_excel(writer, sheet_name = 'Lod3_OHM')
            LAI.to_excel(writer, sheet_name = 'Lod3_LAI')
            st.to_excel(writer, sheet_name = 'Lod3_Storage')
            cnd.to_excel(writer, sheet_name = 'Lod3_Conductance')
            LGP.to_excel(writer, sheet_name = 'Lod3_LGP')
            dr.to_excel(writer, sheet_name = 'Lod3_Drainage')
            VG.to_excel(writer, sheet_name = 'Lod3_VegetationGrowth')
            ANOHM.to_excel(writer, sheet_name = 'Lod3_ANOHM')
            BIOCO2.to_excel(writer, sheet_name = 'Lod3_BiogenCO2')
            MVCND.to_excel(writer, sheet_name = 'Lod3_MaxVegetationConductance')
            por.to_excel(writer, sheet_name = 'Lod3_Porosity')

            writer.save()


    def get_dicts(self,veg, nonveg, water, ref, alb, em, OHM, LAI, st, cnd, LGP, dr, VG, ANOHM, BIOCO2, MVCND, por):

        table_dict = {
            'Emissivity': 'Lod3_Emissivity',
            'OHM': 'Lod3_OHM',
            'Albedo': 'Lod3_Albedo',
            'Leaf Area Index': 'Lod3_LAI',
            'Water Storage': 'Lod3_Storage',
            'Conductance': 'Lod3_Conductance',
            'Leaf Growth Power': 'Lod3_LGP',
            'Drainage': 'Lod3_Drainage',
            'Vegetation Growth' : 'Lod3_VegetationGrowth',
            'ANOHM' : 'Lod3_ANOHM',
            'Biogen CO2' : 'Lod3_BiogenCO2',
            'Max Vegetation Conductance' : 'Lod3_MaxVegetationConductance',
            'Porosity' : 'Lod3_Porosity'
        }
            
        table_dict_ID = {
            'Emissivity': 'Em',
            'OHM': 'OHM',
            'Albedo': 'Alb',
            'Leaf Area Index': 'LAI',
            'Water Storage': 'St',
            'Conductance': 'Cnd',
            'Leaf Growth Power': 'LGP',
            'Drainage': 'Dr',
            'OHM Summer Wet': 'OHMSummerWet' ,	
            'OHM Summer Dry': 'OHMSummerDry',
            'OHM Winter Wet': 'OHMWinterWet',
            'OHM Winter Dry': 'OHMWinterDry',
            'Vegetation Growth' : 'VG',
            'ANOHM' : 'ANOHM',
            'BIOCO2' : 'BIOCO2',
            'MVCND' : 'MVCND',
            'Porosity' : 'Por',

            'Evergreen Tree' : 'Veg',
            'Decidous Tree' : 'Veg',
            'Grass' : 'Veg',
            'Building' : 'NonVeg',
            'Paved' : 'NonVeg',
            'Bare Soil': 'Bsoil',
            'Water' : 'Water'}

        table_dict_pd = {
            'Emissivity': em,
            'OHM': OHM,
            'OHM Summer Wet': OHM ,	
            'OHM Summer Dry': OHM ,
            'OHM Winter Wet': OHM ,
            'OHM Winter Dry': OHM ,
            'Albedo': alb,
            'Leaf Area Index': LAI,
            'Water Storage': st,
            'Conductance': cnd,
            'Leaf Growth Power': LGP,
            'Drainage': dr,
            'Vegetation Growth' : VG,
            'ANOHM' : ANOHM,
            'Biogen CO2' : BIOCO2,
            'Max Vegetation Conductance' : MVCND,
            'Porosity' : por,

            'Evergreen Tree' : veg,
            'Decidous Tree' : veg,
            'Grass' : veg,
            'Building' : nonveg,
            'Paved' : nonveg,
            'Bare Soil' : nonveg,
            'Water' : water
            }

        dict_str_var = {
            'Em': em,
            'OHM': OHM,
            'Alb': alb,
            'LAI': LAI,
            'St': st,
            'Cnd': cnd,
            'LGP': LGP,
            'Dr': dr
            
            }
        
        dict_gen_type = {
            'Paved' : 'NonVeg',
            'Building' : 'NonVeg',
            'Evergreen Tree' : 'Veg',
            'Decidous Tree' : 'Veg',
            'Grass' : 'Veg',
            'Bare Soil' : 'NonVeg',
            'Water' : 'Water', # WATER            
        }
        
        return table_dict,table_dict_ID,table_dict_pd,dict_str_var, dict_gen_type

    def reset_DB_editor(self):
        self.setup_tabs()
        self.dlg.tabWidget.setCurrentIndex(3)

    def run(self):
        '''Run method that performs all the real work'''

        self.setup_tabs()
       # Show the dialog
        self.dlg.show()

        #run the dialog event loop
        result = self.dlg.exec_()

        # See if OK was pressed
        if result:
            print('result')
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
        else:
            self.dlg.__init__()

    #     # Create the dialog with elements (after translation) and keep reference
    #     # Only create GUI ONCE in callback, so that it will only load when the plugin is started
    #     if self.first_start == True:
    #         self.first_start = False
    #         self.dlg = Urban_type_creatorDialog()

 

        # pixmap = QPixmap(r'C:\Script\NGEO306\urban_type_creator\image.JPG')

#            pixmap = QPixmap(r'C:\Script\NGEO306\urban_type_creator\image.JPG')
            # pixmap_rescaled = pixmap.scaled(100,100, QtCore.Qt.KeepAspectRatio) +
            # pixmap_rescaled.show()
        #)

        # '<img src='+r'C:\Script\NGEO306\urban_type_creator\image.JPG' + ' width='500' height=Auto>' 

    #    # Show the dialog
    #     self.dlg.show()

    #     #run the dialog event loop
    #     result = self.dlg.exec_()

    #     # See if OK was pressed
    #     if result:
    #         print('result')
    #         # Do something useful here - delete the line containing pass and
    #         # substitute with your code.
    #         pass
    #     else:
    #         self.dlg.__init__()



    

    # # Info Button
    # def typeInfo(self): 
       
    #     print('hej')

    #     self.dlg.Qlabel.clear()
    #     # self.dlg.Qlabel.clear()
    #     db_path = self.plugin_dir + '/database_copy.xlsx'

    #     # db = pd.read_csv(r'C:\Script\NGEO306\GHSL\UrbanTypes.txt', sep= '\t')
    #     db = pd.read_excel(db_path, sheet_name= 'Lod1_Types', index_col=  'ID')

    #     type_list = []
    #     for i in range(len(db)):
    #         type_list.append(str(db['Type'].iloc[i]) + ', ' + str(db['Location'].iloc[i]))
    #     db['type_location'] = type_list

        
    #     urb_type = dlg.comboBoxTableSelect.currentText() 
    #     selection = db.loc[db['type_location'] == urb_type]
        
    #     if len(urb_type)>0:
    #         dlg_.textBrowser.setText(
    #             'Urban Type Info: '+ selection['Type'].item() +
    #             '\n\nLocation: ' +  selection['Location'].item() +
    #             '\n\nPeriod: ' + str(selection['Period'].item()) + 
    #             '\n\nDescription: ' + str(selection['Description'].item()) +
    #             '\n\nAuthor: ' + str(selection['Author'].item())
    #             )
    #         try:
    #             url = str(selection['Url'].item())
            
    #             data = urllib.request.urlopen(url).read()
    #             pixmap = QPixmap()
    #             pixmap.loadFromData(data)
    #             dlg.Qlabel.setPixmap(pixmap.scaled(500,700, QtCore.Qt.KeepAspectRatio))
    #         except:
    #             dlg.Qlabel.setText('No reference Image avalible for this Type')

    #     else:
    #         QMessageBox.information(None, 'Error', 'No Type Selected')

    # def resetPlugin(self):
    #     self.layerComboManagerPointField.clear()
    #     self.layerComboManagerPoint.clear()
    #     self.dlg.comboBoxVector.clear()
    #     self.dlg.comboBoxField.clear()
    #     self.dlg.comboBoxField.setCurrentIndex(-1)
    #     self.dlg.textBrowser.clear()
    #     self.dlg.textOutput.clear()

    #     for i in range(1,14):
    #         Ls = eval('self.dlg.comboBoxClass' + str(i))
    #         Ls.clear()
    #         vars()['self.dlg.comboBoxClass' + str(i)] = Ls

    #         Rs = eval('self.dlg.comboBoxNew' + str(i))
    #         Rs.clear()
    #         vars()['self.dlg.comboBoxNew' + str(i)] = Rs


    def closeEvent(self, event):
        self.reset_form()
        self.resetPlugin()


# # -*- coding: utf-8 -*-
# '''
# /***************************************************************************
#  Urban_type_creator
#                                  A QGIS plugin
#  This plugin prepare suews lib data
#  Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
#                               -------------------
#         begin                : 2021-05-20
#         git sha              : $Format:%H$
#         copyright            : (C) 2021 by GU
#         email                : oskar.backlin@gu.se
#  ***************************************************************************/

# /***************************************************************************
#  *                                                                         *
#  *   This program is free software; you can redistribute it and/or modify  *
#  *   it under the terms of the GNU General Public License as published by  *
#  *   the Free Software Foundation; either version 2 of the License, or     *
#  *   (at your option) any later version.                                   *
#  *                                                                         *
#  ***************************************************************************/
# '''
# from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
# from qgis.PyQt.QtGui import QIcon, QPixmap
# from qgis.PyQt.QtWidgets import QFileDialog, QAction, QMessageBox
# from qgis.gui import QgsMapLayerComboBox, QgsFieldComboBox, QgsMessageBar
# from qgis.core import QgsVectorLayer, QgsMapLayerProxyModel, Qgis, QgsProject, QgsFieldProxyModel, QgsField
# # from ..urban_type_edior.urban_type_edior import urban_type_editor
# # Initialize Qt resources from file resources.py
# from .resources import *
# from pathlib import Path
# import geopandas as gpd
# import webbrowser
# import pandas as pd
# from timezonefinder import TimezoneFinder as tf
# import urllib
# import time


# # Import the code for the dialog
# from .Urban_type_creator_dialog import Urban_type_creatorDialog
# import os.path


# class Urban_type_creator(object):
#     '''QGIS Plugin Implementation.'''

#     def __init__(self, iface):
#         print('__init__')
#         '''Constructor.

#         :param iface: An interface instance that will be passed to this class
#             which provides the hook by which you can manipulate the QGIS
#             application at run time.
#         :type iface: QgsInterface
#         '''
#         # Save reference to the QGIS interface
#         self.iface = iface
#         # initialize plugin directory
#         self.plugin_dir = os.path.dirname(__file__)
#         # initialize locale
#         locale = QSettings().value('locale/userLocale')[0:2]
#         locale_path = os.path.join(
#             self.plugin_dir,
#             'i18n',
#             'Urban_type_creator_{}.qm'.format(locale))

#         if os.path.exists(locale_path):
#             self.translator = QTranslator()
#             self.translator.load(locale_path)
#             QCoreApplication.installTranslator(self.translator)

#         # Declare instance attributes
#         self.actions = []
#         self.menu = self.tr(u'&Urban_type_creator')

#         self.dlg = Urban_type_creatorDialog()
#         # Check if plugin was started the first time in current QGIS session
#         # Must be set in initGui() to survive plugin reloads
#         self.first_start = None

#         # Declare Variables
#         self.outputfile = None

       


#     # noinspection PyMethodMayBeStatic
#     def tr(self, message):
#         '''Get the translation for a string using Qt translation API.

#         We implement this ourselves since we do not inherit QObject.

#         :param message: String for translation.
#         :type message: str, QString

#         :returns: Translated version of message.
#         :rtype: QString
#         '''
#         # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
#         return QCoreApplication.translate('Urban_type_creator', message)


#     def add_action(
#         self,
#         icon_path,
#         text,
#         callback,
#         enabled_flag=True,
#         add_to_menu=True,
#         add_to_toolbar=True,
#         status_tip=None,
#         whats_this=None,
#         parent=None):
#         '''Add a toolbar icon to the toolbar.

#         :param icon_path: Path to the icon for this action. Can be a resource
#             path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
#         :type icon_path: str

#         :param text: Text that should be shown in menu items for this action.
#         :type text: str

#         :param callback: Function to be called when the action is triggered.
#         :type callback: function

#         :param enabled_flag: A flag indicating if the action should be enabled
#             by default. Defaults to True.
#         :type enabled_flag: bool

#         :param add_to_menu: Flag indicating whether the action should also
#             be added to the menu. Defaults to True.
#         :type add_to_menu: bool

#         :param add_to_toolbar: Flag indicating whether the action should also
#             be added to the toolbar. Defaults to True.
#         :type add_to_toolbar: bool

#         :param status_tip: Optional text to show in a popup when mouse pointer
#             hovers over the action.
#         :type status_tip: str

#         :param parent: Parent widget for the new action. Defaults None.
#         :type parent: QWidget

#         :param whats_this: Optional text to show in the status bar when the
#             mouse pointer hovers over the action.

#         :returns: The action that was created. Note that the action is also
#             added to self.actions list.
#         :rtype: QAction
#         '''

#         icon = QIcon(icon_path)
#         action = QAction(icon, text, parent)
#         action.triggered.connect(callback)
#         action.setEnabled(enabled_flag)

#         if status_tip is not None:
#             action.setStatusTip(status_tip)

#         if whats_this is not None:
#             action.setWhatsThis(whats_this)

#         if add_to_toolbar:
#             # Adds plugin icon to Plugins toolbar
#             self.iface.addToolBarIcon(action)

#         if add_to_menu:
#             self.iface.addPluginToMenu(
#                 self.menu,
#                 action)

#         self.actions.append(action)

#         return action

#     def initGui(self):
#         print('init_GUI')
#         '''Create the menu entries and toolbar icons inside the QGIS GUI.'''

#         icon_path = ':/plugins/Urban_type_creator/icon.png'
#         self.add_action(
#             icon_path,
#             text=self.tr(u''),
#             callback=self.run,
#             parent=self.iface.mainWindow())

#         # will be set False in run()
#         self.first_start = False


#     def unload(self):
#         '''Removes the plugin menu item and icon from QGIS GUI.'''
#         for action in self.actions:
#             self.iface.removePluginMenu(
#                 self.tr(u'&Urban_type_creator'),
#                 action)
#             self.iface.removeToolBarIcon(action)


#     def run(self):
#         print('run')
#         '''Run method that performs all the real work'''

#         # Create the dialog with elements (after translation) and keep reference
#         # Only create GUI ONCE in callback, so that it will only load when the plugin is started
#         if self.first_start == True:
#             self.first_start = False
#             self.dlg = Urban_type_creatorDialog()

#        # Use or not ? 
        
#         self.dlg.comboBoxField.clear()
#         self.dlg.comboBoxField.setCurrentIndex(-1)
#         self.dlg.comboBoxField.setDisabled(True)
#         self.dlg.comboBoxTableSelect.clear()
#         self.dlg.textBrowser.clear()
#         self.dlg.textOutput.clear()
#         self.dlg.Qlabel.clear()
        
#         self.layerComboManagerPoint = self.dlg.comboBoxVector
#         self.layerComboManagerPoint.setCurrentIndex(-1)
#         self.layerComboManagerPoint.setFilters(QgsMapLayerProxyModel.PolygonLayer)
#         #self.layerComboManagerPoint.setFixedWidth(250)

#         self.layerComboManagerPointField = self.dlg.comboBoxField
#         self.layerComboManagerPointField.setFilters(QgsFieldProxyModel.AllTypes)
#         # self.layerComboManagerPointField.setFixedWidth(250)
#         self.layerComboManagerPoint.layerChanged.connect(self.layerComboManagerPointField.setLayer)
#         self.layerComboManagerPointField.setEnabled(True)
#         # tf().timezone_at(lng=x, lat=y)

#         # x = vectorlayer.to_crs('EPSG:4326').loc[0:0].representative_point().x.item()
#         # y = vectorlayer.to_crs('EPSG:4326').loc[0:0].representative_point().y.item()
        
#         # Set up for the Help button
#         self.dlg.helpButton_2.clicked.connect(self.typeInfo)

#         # Set up for the run button
#         self.dlg.runButton.clicked.connect(self.start_progress)

#         self.dlg.comboBoxField.fieldChanged.connect(self.field_changed) 

#          # Set up of file save dialog
#         self.fileDialog = QFileDialog()
#         self.dlg.pushButtonSave.clicked.connect(self.savefile)



#         # Read Database 
#  #       db = pd.read_csv(r'C:\Script\NGEO306\GHSL\UrbanTypes.txt', sep= '\t')
#         db_path =r'C:\Script\NGEO306\database_copy.xlsx'
#         db = pd.read_excel(db_path, sheet_name= 'Lod1_Types', index_col=  'ID')

#         type_list = []
#         for i in range(len(db)):
#             type_list.append(str(db['Type'].iloc[i]) + ', ' + str(db['Location'].iloc[i]))
#         db['type_location'] = type_list

#         self.dlg.comboBoxTableSelect.addItems(sorted(type_list)) 
#         self.dlg.comboBoxTableSelect.setCurrentIndex(-1)

#         for i in range(1,14):
#             Ls = eval('self.dlg.comboBoxClass' + str(i))
#             Ls.clear()
#             vars()['self.dlg.comboBoxClass' + str(i)] = Ls

#             Rs = eval('self.dlg.comboBoxNew' + str(i))
#             Rs.clear()
#             Rs.addItems(sorted(type_list))
#             Rs.setCurrentIndex(-1)
#             vars()['self.dlg.comboBoxNew' + str(i)] = Rs


        

#         # pixmap = QPixmap(r'C:\Script\NGEO306\urban_type_creator\image.JPG')

# #            pixmap = QPixmap(r'C:\Script\NGEO306\urban_type_creator\image.JPG')
#             # pixmap_rescaled = pixmap.scaled(100,100, QtCore.Qt.KeepAspectRatio) +
#             # pixmap_rescaled.show()
#         #)

#         # '<img src='+r'C:\Script\NGEO306\urban_type_creator\image.JPG' + ' width='500' height=Auto>' 

#        # Show the dialog
#         self.dlg.show()

#         #run the dialog event loop
#         result = self.dlg.exec_()

#         # See if OK was pressed
#         if result:
#             print('result')
#             # Do something useful here - delete the line containing pass and
#             # substitute with your code.
#             pass
#         else:
#             self.dlg.__init__()



#     def field_changed(self, field):
#         #get current layer
#         layer = self.layerComboManagerPoint.currentLayer()
#         # get index of the field
#         i = layer.fields().indexOf(field)
#         # get unique values
#         unique_values = layer.uniqueValues(i)    
#         #remove all values from comboBoxAttribute

#         len_uv = len(unique_values)

#         # Set set to string. ComboBox does not accept other than string ATM
#         # Have not yet found a way to fix this. 
#         # this loop will do the trick as workaround

#         if isinstance(unique_values, str):
#             att_list = unique_values
#         else:
#             att_list = []
#             for i in unique_values:
#                 att_list.append(str(i))

#         for i in range(1,14):
#             # Oc == Old Class
#             Oc = eval('self.dlg.comboBoxClass' + str(i))
#             Oc.clear()
#             Oc.setDisabled(True)
#             vars()['self.dlg.comboBoxClass' + str(i)] = Oc

#             Nc = eval('self.dlg.comboBoxNew' + str(i))
#             Nc.setDisabled(True)
#             Nc.setCurrentIndex(-1)
#             vars()['self.dlg.comboBoxNew' + str(i)] = Nc

#             # Te = eval('self.dlg.editClassButton_' + str(i))
#             # Te.setDisabled(True)
#             # vars()['self.dlg.editClassButton_' + str(i)] = Te

#         idx = 1
#         for i in range(len_uv):
#             if idx > 13:
#                 break 
#             # Left side
#             Oc = eval('self.dlg.comboBoxClass' + str(idx))
#             #Oc.setEnabled(True)
#             Oc.addItems(att_list)
#             Oc.setCurrentIndex(i)
#             vars()['self.dlg.comboBoxClass' + str(idx)] = Oc

#             Nc = eval('self.dlg.comboBoxNew' + str(idx))
#             Nc.setEnabled(True)
#             vars()['self.dlg.comboBoxNew' + str(idx)] = Nc


#             idx += 1    

#     # Info Button
#     def typeInfo(self): 
       
#             self.dlg.Qlabel.clear()
#             # self.dlg.Qlabel.clear()
#             db_path =r'C:\Script\NGEO306\database_copy.xlsx'

#             # db = pd.read_csv(r'C:\Script\NGEO306\GHSL\UrbanTypes.txt', sep= '\t')
#             db = pd.read_excel(db_path, sheet_name= 'Lod1_Types', index_col=  'ID')

#             type_list = []
#             for i in range(len(db)):
#                 type_list.append(str(db['Type'].iloc[i]) + ', ' + str(db['Location'].iloc[i]))
#             db['type_location'] = type_list

            
#             urb_type = self.dlg.comboBoxTableSelect.currentText() 
#             selection = db.loc[db['type_location'] == urb_type]
            
#             if len(urb_type)>0:
#                 self.dlg.textBrowser.setText(
#                     'Urban Type Info: '+ selection['Type'].item() +
#                     '\n\nLocation: ' +  selection['Location'].item() +
#                     '\n\nPeriod: ' + str(selection['Period'].item()) + 
#                     '\n\nDescription: ' + str(selection['Description'].item()) +
#                     '\n\nAuthor: ' + str(selection['Author'].item())
#                     )
#                 try:
#                     url = str(selection['Url'].item())
                
#                     data = urllib.request.urlopen(url).read()
#                     pixmap = QPixmap()
#                     pixmap.loadFromData(data)
#                     self.dlg.Qlabel.setPixmap(pixmap.scaled(500,700, QtCore.Qt.KeepAspectRatio))
#                 except:
#                     self.dlg.Qlabel.setText('No reference Image avalible for this Type')

#             else:
#                 QMessageBox.information(None, 'Error', 'No Type Selected')


#     def savefile(self):
#         self.outputfile = self.fileDialog.getSaveFileName(None, 'Save File As:', None, 'Shapefiles (*.shp)')
#         self.dlg.textOutput.setText(self.outputfile[0])

#     def help(self):
#         url = 'https://github.com/gusbacos/UTDB'
#         webbrowser.open_new_tab(url)

#     def start_progress(self):
#         print('in start_progress')

#         att_field =  self.layerComboManagerPointField.currentText()

#         vlayer = self.layerComboManagerPoint.currentLayer()

#         # Read Vectorlayer Path
#         gdf = gpd.read_file(str(vlayer.dataProvider().dataSourceUri()))

#         dict_reclass = {}

#         idx = 1
#         for i in range(len(set(gdf[att_field]))):
#             if idx > 13:
#                 break 
#             # Left side
#             Oc = eval('self.dlg.comboBoxClass' + str(idx))
#             oldField = Oc.currentText()
#             vars()['self.dlg.comboBoxClass' + str(idx)] = Oc
            
#             # Right Side
#             Nc = eval('self.dlg.comboBoxNew' + str(idx))
#             newField = Nc.currentText()
#             vars()['self.dlg.comboBoxNew' + str(idx)] = Nc
            
#             dict_reclass[str(oldField)] = str(newField)

#             idx += 1

#         print(dict_reclass)
     
#         # Backup not using GeoPandas ********
#         # vlayer_provider=vlayer.dataProvider()
#         # vlayer.dataProvider().addAttributes([QgsField('newfield',QVariant.String)])
#         # vlayer.updateFields()
#         # print (layer.fields().names())
#         # #layer = iface.activeLayer()
#         # newfieldindex = vlayer.fields().indexFromName('newfield') #The field needs to be created in advance
#         # attrmap = {} #dictionary of feature id: {field index: new value}
#         # for f in vlayer.getFeatures():
#         #     if f[field] in dict_reclass:
#         #         attrmap[f.id()] = {newfieldindex:dict_reclass[f[field]]}

#         # vlayer.dataProvider().changeAttributeValues(attrmap)

#         gdf['New_class'] = gdf[att_field].map(dict_reclass)

#         #print(gdf[[att_field,'New_class']].head())
#         gdf.to_file(self.outputfile[0])

#         vlayer = QgsVectorLayer(self.outputfile[0], Path(self.outputfile[0]).name[:-4])

#         QgsProject.instance().addMapLayer(vlayer)
#         QMessageBox.information(None, 'Process Complete', 'Your reclassified shapefile has been added to project')

        


#     def resetPlugin(self):
#         self.layerComboManagerPointField.clear()
#         self.layerComboManagerPoint.clear()
#         self.dlg.comboBoxVector.clear()
#         self.dlg.comboBoxField.clear()
#         self.dlg.comboBoxField.setCurrentIndex(-1)
#         self.dlg.textBrowser.clear()
#         self.dlg.textOutput.clear()

#         for i in range(1,14):
#             Ls = eval('self.dlg.comboBoxClass' + str(i))
#             Ls.clear()
#             vars()['self.dlg.comboBoxClass' + str(i)] = Ls

#             Rs = eval('self.dlg.comboBoxNew' + str(i))
#             Rs.clear()
#             vars()['self.dlg.comboBoxNew' + str(i)] = Rs


#     def closeEvent(self, event):
#         self.reset_form()
#         self.resetPlugin()